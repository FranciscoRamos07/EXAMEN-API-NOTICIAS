{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _declaration = require('./declaration');\nvar _declaration2 = _interopRequireDefault(_declaration);\nvar _tokenize = require('./tokenize');\nvar _tokenize2 = _interopRequireDefault(_tokenize);\nvar _comment = require('./comment');\nvar _comment2 = _interopRequireDefault(_comment);\nvar _atRule = require('./at-rule');\nvar _atRule2 = _interopRequireDefault(_atRule);\nvar _root = require('./root');\nvar _root2 = _interopRequireDefault(_root);\nvar _rule = require('./rule');\nvar _rule2 = _interopRequireDefault(_rule);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar Parser = function () {\n  function Parser(input) {\n    _classCallCheck(this, Parser);\n    this.input = input;\n    this.pos = 0;\n    this.root = new _root2.default();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.root.source = {\n      input: input,\n      start: {\n        line: 1,\n        column: 1\n      }\n    };\n  }\n  Parser.prototype.tokenize = function tokenize() {\n    this.tokens = (0, _tokenize2.default)(this.input);\n  };\n  Parser.prototype.loop = function loop() {\n    var token = void 0;\n    while (this.pos < this.tokens.length) {\n      token = this.tokens[this.pos];\n      switch (token[0]) {\n        case 'space':\n        case ';':\n          this.spaces += token[1];\n          break;\n        case '}':\n          this.end(token);\n          break;\n        case 'comment':\n          this.comment(token);\n          break;\n        case 'at-word':\n          this.atrule(token);\n          break;\n        case '{':\n          this.emptyRule(token);\n          break;\n        default:\n          this.other();\n          break;\n      }\n      this.pos += 1;\n    }\n    this.endFile();\n  };\n  Parser.prototype.comment = function comment(token) {\n    var node = new _comment2.default();\n    this.init(node, token[2], token[3]);\n    node.source.end = {\n      line: token[4],\n      column: token[5]\n    };\n    var text = token[1].slice(2, -2);\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  };\n  Parser.prototype.emptyRule = function emptyRule(token) {\n    var node = new _rule2.default();\n    this.init(node, token[2], token[3]);\n    node.selector = '';\n    node.raws.between = '';\n    this.current = node;\n  };\n  Parser.prototype.other = function other() {\n    var token = void 0;\n    var end = false;\n    var type = null;\n    var colon = false;\n    var bracket = null;\n    var brackets = [];\n    var start = this.pos;\n    while (this.pos < this.tokens.length) {\n      token = this.tokens[this.pos];\n      type = token[0];\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token;\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(this.tokens.slice(start, this.pos + 1));\n            return;\n          } else {\n            break;\n          }\n        } else if (type === '{') {\n          this.rule(this.tokens.slice(start, this.pos + 1));\n          return;\n        } else if (type === '}') {\n          this.pos -= 1;\n          end = true;\n          break;\n        } else if (type === ':') {\n          colon = true;\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n        if (brackets.length === 0) bracket = null;\n      }\n      this.pos += 1;\n    }\n    if (this.pos === this.tokens.length) {\n      this.pos -= 1;\n      end = true;\n    }\n    if (brackets.length > 0) this.unclosedBracket(bracket);\n    if (end && colon) {\n      while (this.pos > start) {\n        token = this.tokens[this.pos][0];\n        if (token !== 'space' && token !== 'comment') break;\n        this.pos -= 1;\n      }\n      this.decl(this.tokens.slice(start, this.pos + 1));\n      return;\n    }\n    this.unknownWord(start);\n  };\n  Parser.prototype.rule = function rule(tokens) {\n    tokens.pop();\n    var node = new _rule2.default();\n    this.init(node, tokens[0][2], tokens[0][3]);\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n    this.raw(node, 'selector', tokens);\n    this.current = node;\n  };\n  Parser.prototype.decl = function decl(tokens) {\n    var node = new _declaration2.default();\n    this.init(node);\n    var last = tokens[tokens.length - 1];\n    if (last[0] === ';') {\n      this.semicolon = true;\n      tokens.pop();\n    }\n    if (last[4]) {\n      node.source.end = {\n        line: last[4],\n        column: last[5]\n      };\n    } else {\n      node.source.end = {\n        line: last[2],\n        column: last[3]\n      };\n    }\n    while (tokens[0][0] !== 'word') {\n      node.raws.before += tokens.shift()[1];\n    }\n    node.source.start = {\n      line: tokens[0][2],\n      column: tokens[0][3]\n    };\n    node.prop = '';\n    while (tokens.length) {\n      var type = tokens[0][0];\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break;\n      }\n      node.prop += tokens.shift()[1];\n    }\n    node.raws.between = '';\n    var token = void 0;\n    while (tokens.length) {\n      token = tokens.shift();\n      if (token[0] === ':') {\n        node.raws.between += token[1];\n        break;\n      } else {\n        node.raws.between += token[1];\n      }\n    }\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0];\n      node.prop = node.prop.slice(1);\n    }\n    node.raws.between += this.spacesAndCommentsFromStart(tokens);\n    this.precheckMissedSemicolon(tokens);\n    for (var i = tokens.length - 1; i > 0; i--) {\n      token = tokens[i];\n      if (token[1] === '!important') {\n        node.important = true;\n        var string = this.stringFrom(tokens, i);\n        string = this.spacesFromEnd(tokens) + string;\n        if (string !== ' !important') node.raws.important = string;\n        break;\n      } else if (token[1] === 'important') {\n        var cache = tokens.slice(0);\n        var str = '';\n        for (var j = i; j > 0; j--) {\n          var _type = cache[j][0];\n          if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n            break;\n          }\n          str = cache.pop()[1] + str;\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true;\n          node.raws.important = str;\n          tokens = cache;\n        }\n      }\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break;\n      }\n    }\n    this.raw(node, 'value', tokens);\n    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);\n  };\n  Parser.prototype.atrule = function atrule(token) {\n    var node = new _atRule2.default();\n    node.name = token[1].slice(1);\n    if (node.name === '') {\n      this.unnamedAtrule(node, token);\n    }\n    this.init(node, token[2], token[3]);\n    var last = false;\n    var open = false;\n    var params = [];\n    this.pos += 1;\n    while (this.pos < this.tokens.length) {\n      token = this.tokens[this.pos];\n      if (token[0] === ';') {\n        node.source.end = {\n          line: token[2],\n          column: token[3]\n        };\n        this.semicolon = true;\n        break;\n      } else if (token[0] === '{') {\n        open = true;\n        break;\n      } else if (token[0] === '}') {\n        this.end(token);\n        break;\n      } else {\n        params.push(token);\n      }\n      this.pos += 1;\n    }\n    if (this.pos === this.tokens.length) {\n      last = true;\n    }\n    node.raws.between = this.spacesAndCommentsFromEnd(params);\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params);\n      this.raw(node, 'params', params);\n      if (last) {\n        token = params[params.length - 1];\n        node.source.end = {\n          line: token[4],\n          column: token[5]\n        };\n        this.spaces = node.raws.between;\n        node.raws.between = '';\n      }\n    } else {\n      node.raws.afterName = '';\n      node.params = '';\n    }\n    if (open) {\n      node.nodes = [];\n      this.current = node;\n    }\n  };\n  Parser.prototype.end = function end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n    this.semicolon = false;\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.spaces = '';\n    if (this.current.parent) {\n      this.current.source.end = {\n        line: token[2],\n        column: token[3]\n      };\n      this.current = this.current.parent;\n    } else {\n      this.unexpectedClose(token);\n    }\n  };\n  Parser.prototype.endFile = function endFile() {\n    if (this.current.parent) this.unclosedBlock();\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n  };\n\n  // Helpers\n\n  Parser.prototype.init = function init(node, line, column) {\n    this.current.push(node);\n    node.source = {\n      start: {\n        line: line,\n        column: column\n      },\n      input: this.input\n    };\n    node.raws.before = this.spaces;\n    this.spaces = '';\n    if (node.type !== 'comment') this.semicolon = false;\n  };\n  Parser.prototype.raw = function raw(node, prop, tokens) {\n    var token = void 0,\n      type = void 0;\n    var length = tokens.length;\n    var value = '';\n    var clean = true;\n    for (var i = 0; i < length; i += 1) {\n      token = tokens[i];\n      type = token[0];\n      if (type === 'comment' || type === 'space' && i === length - 1) {\n        clean = false;\n      } else {\n        value += token[1];\n      }\n    }\n    if (!clean) {\n      var raw = tokens.reduce(function (all, i) {\n        return all + i[1];\n      }, '');\n      node.raws[prop] = {\n        value: value,\n        raw: raw\n      };\n    }\n    node[prop] = value;\n  };\n  Parser.prototype.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n    var lastTokenType = void 0;\n    var spaces = '';\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n    return spaces;\n  };\n  Parser.prototype.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n    var next = void 0;\n    var spaces = '';\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      spaces += tokens.shift()[1];\n    }\n    return spaces;\n  };\n  Parser.prototype.spacesFromEnd = function spacesFromEnd(tokens) {\n    var lastTokenType = void 0;\n    var spaces = '';\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n    return spaces;\n  };\n  Parser.prototype.stringFrom = function stringFrom(tokens, from) {\n    var result = '';\n    for (var i = from; i < tokens.length; i++) {\n      result += tokens[i][1];\n    }\n    tokens.splice(from, tokens.length - from);\n    return result;\n  };\n  Parser.prototype.colon = function colon(tokens) {\n    var brackets = 0;\n    var token = void 0,\n      type = void 0,\n      prev = void 0;\n    for (var i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n      type = token[0];\n      if (type === '(') {\n        brackets += 1;\n      } else if (type === ')') {\n        brackets -= 1;\n      } else if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token);\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue;\n        } else {\n          return i;\n        }\n      }\n      prev = token;\n    }\n    return false;\n  };\n\n  // Errors\n\n  Parser.prototype.unclosedBracket = function unclosedBracket(bracket) {\n    throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n  };\n  Parser.prototype.unknownWord = function unknownWord(start) {\n    var token = this.tokens[start];\n    throw this.input.error('Unknown word', token[2], token[3]);\n  };\n  Parser.prototype.unexpectedClose = function unexpectedClose(token) {\n    throw this.input.error('Unexpected }', token[2], token[3]);\n  };\n  Parser.prototype.unclosedBlock = function unclosedBlock() {\n    var pos = this.current.source.start;\n    throw this.input.error('Unclosed block', pos.line, pos.column);\n  };\n  Parser.prototype.doubleColon = function doubleColon(token) {\n    throw this.input.error('Double colon', token[2], token[3]);\n  };\n  Parser.prototype.unnamedAtrule = function unnamedAtrule(node, token) {\n    throw this.input.error('At-rule without name', token[2], token[3]);\n  };\n  Parser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {\n    // Hook for Safe Parser\n    tokens;\n  };\n  Parser.prototype.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n    var colon = this.colon(tokens);\n    if (colon === false) return;\n    var founded = 0;\n    var token = void 0;\n    for (var j = colon - 1; j >= 0; j--) {\n      token = tokens[j];\n      if (token[0] !== 'space') {\n        founded += 1;\n        if (founded === 2) break;\n      }\n    }\n    throw this.input.error('Missed semicolon', token[2], token[3]);\n  };\n  return Parser;\n}();\nexports.default = Parser;\nmodule.exports = exports['default'];","map":{"version":3,"names":["_declaration","require","_tokenize","_comment","_atRule","_root","_rule","Parser","input","_classCallCheck","pos","root","_root2","default","current","spaces","semicolon","source","start","line","column","tokenize","tokens","_tokenize2","loop","token","length","end","comment","atrule","emptyRule","other","endFile","node","_comment2","init","text","slice","test","raws","left","right","match","_rule2","selector","between","type","colon","bracket","brackets","push","decl","rule","pop","unclosedBracket","unknownWord","spacesAndCommentsFromEnd","raw","_declaration2","last","before","shift","prop","spacesAndCommentsFromStart","precheckMissedSemicolon","i","important","string","stringFrom","spacesFromEnd","cache","str","j","_type","trim","indexOf","value","checkMissedSemicolon","_atRule2","name","unnamedAtrule","open","params","afterName","nodes","after","parent","unexpectedClose","unclosedBlock","clean","reduce","all","lastTokenType","next","from","result","splice","prev","doubleColon","error","founded"],"sources":["C:\\Users\\Francisco\\Documents\\GitHub\\examenApi\\EXAMEN-API-NOTICIAS\\node_modules\\perfectionist\\node_modules\\postcss\\lib\\parser.es6"],"sourcesContent":["import Declaration from './declaration';\nimport tokenizer   from './tokenize';\nimport Comment     from './comment';\nimport AtRule      from './at-rule';\nimport Root        from './root';\nimport Rule        from './rule';\n\nexport default class Parser {\n\n    constructor(input) {\n        this.input = input;\n\n        this.pos       = 0;\n        this.root      = new Root();\n        this.current   = this.root;\n        this.spaces    = '';\n        this.semicolon = false;\n\n        this.root.source = { input, start: { line: 1, column: 1 } };\n    }\n\n    tokenize() {\n        this.tokens = tokenizer(this.input);\n    }\n\n    loop() {\n        let token;\n        while ( this.pos < this.tokens.length ) {\n            token = this.tokens[this.pos];\n\n            switch ( token[0] ) {\n\n            case 'space':\n            case ';':\n                this.spaces += token[1];\n                break;\n\n            case '}':\n                this.end(token);\n                break;\n\n            case 'comment':\n                this.comment(token);\n                break;\n\n            case 'at-word':\n                this.atrule(token);\n                break;\n\n            case '{':\n                this.emptyRule(token);\n                break;\n\n            default:\n                this.other();\n                break;\n            }\n\n            this.pos += 1;\n        }\n        this.endFile();\n    }\n\n    comment(token) {\n        let node = new Comment();\n        this.init(node, token[2], token[3]);\n        node.source.end = { line: token[4], column: token[5] };\n\n        let text = token[1].slice(2, -2);\n        if ( /^\\s*$/.test(text) ) {\n            node.text       = '';\n            node.raws.left  = text;\n            node.raws.right = '';\n        } else {\n            let match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n            node.text       = match[2];\n            node.raws.left  = match[1];\n            node.raws.right = match[3];\n        }\n    }\n\n    emptyRule(token) {\n        let node = new Rule();\n        this.init(node, token[2], token[3]);\n        node.selector = '';\n        node.raws.between = '';\n        this.current = node;\n    }\n\n    other() {\n        let token;\n        let end      = false;\n        let type     = null;\n        let colon    = false;\n        let bracket  = null;\n        let brackets = [];\n\n        let start = this.pos;\n        while ( this.pos < this.tokens.length ) {\n            token = this.tokens[this.pos];\n            type  = token[0];\n\n            if ( type === '(' || type === '[' ) {\n                if ( !bracket ) bracket = token;\n                brackets.push(type === '(' ? ')' : ']');\n\n            } else if ( brackets.length === 0 ) {\n                if ( type === ';' ) {\n                    if ( colon ) {\n                        this.decl(this.tokens.slice(start, this.pos + 1));\n                        return;\n                    } else {\n                        break;\n                    }\n\n                } else if ( type === '{' ) {\n                    this.rule(this.tokens.slice(start, this.pos + 1));\n                    return;\n\n                } else if ( type === '}' ) {\n                    this.pos -= 1;\n                    end = true;\n                    break;\n\n                } else if ( type === ':' ) {\n                    colon = true;\n                }\n\n            } else if ( type === brackets[brackets.length - 1] ) {\n                brackets.pop();\n                if ( brackets.length === 0 ) bracket = null;\n            }\n\n            this.pos += 1;\n        }\n        if ( this.pos === this.tokens.length ) {\n            this.pos -= 1;\n            end = true;\n        }\n\n        if ( brackets.length > 0 ) this.unclosedBracket(bracket);\n\n        if ( end && colon ) {\n            while ( this.pos > start ) {\n                token = this.tokens[this.pos][0];\n                if ( token !== 'space' && token !== 'comment' ) break;\n                this.pos -= 1;\n            }\n            this.decl(this.tokens.slice(start, this.pos + 1));\n            return;\n        }\n\n        this.unknownWord(start);\n    }\n\n    rule(tokens) {\n        tokens.pop();\n\n        let node = new Rule();\n        this.init(node, tokens[0][2], tokens[0][3]);\n\n        node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node, 'selector', tokens);\n        this.current = node;\n    }\n\n    decl(tokens) {\n        let node = new Declaration();\n        this.init(node);\n\n        let last = tokens[tokens.length - 1];\n        if ( last[0] === ';' ) {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        if ( last[4] ) {\n            node.source.end = { line: last[4], column: last[5] };\n        } else {\n            node.source.end = { line: last[2], column: last[3] };\n        }\n\n        while ( tokens[0][0] !== 'word' ) {\n            node.raws.before += tokens.shift()[1];\n        }\n        node.source.start = { line: tokens[0][2], column: tokens[0][3] };\n\n        node.prop = '';\n        while ( tokens.length ) {\n            let type = tokens[0][0];\n            if ( type === ':' || type === 'space' || type === 'comment' ) {\n                break;\n            }\n            node.prop += tokens.shift()[1];\n        }\n\n        node.raws.between = '';\n\n        let token;\n        while ( tokens.length ) {\n            token = tokens.shift();\n\n            if ( token[0] === ':' ) {\n                node.raws.between += token[1];\n                break;\n            } else {\n                node.raws.between += token[1];\n            }\n        }\n\n        if ( node.prop[0] === '_' || node.prop[0] === '*' ) {\n            node.raws.before += node.prop[0];\n            node.prop = node.prop.slice(1);\n        }\n        node.raws.between += this.spacesAndCommentsFromStart(tokens);\n        this.precheckMissedSemicolon(tokens);\n\n        for ( let i = tokens.length - 1; i > 0; i-- ) {\n            token = tokens[i];\n            if ( token[1] === '!important' ) {\n                node.important = true;\n                let string = this.stringFrom(tokens, i);\n                string = this.spacesFromEnd(tokens) + string;\n                if ( string !== ' !important' ) node.raws.important = string;\n                break;\n\n            } else if (token[1] === 'important') {\n                let cache = tokens.slice(0);\n                let str   = '';\n                for ( let j = i; j > 0; j-- ) {\n                    let type = cache[j][0];\n                    if ( str.trim().indexOf('!') === 0 && type !== 'space' ) {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if ( str.trim().indexOf('!') === 0 ) {\n                    node.important = true;\n                    node.raws.important = str;\n                    tokens = cache;\n                }\n            }\n\n            if ( token[0] !== 'space' && token[0] !== 'comment' ) {\n                break;\n            }\n        }\n\n        this.raw(node, 'value', tokens);\n\n        if ( node.value.indexOf(':') !== -1 ) this.checkMissedSemicolon(tokens);\n    }\n\n    atrule(token) {\n        let node  = new AtRule();\n        node.name = token[1].slice(1);\n        if ( node.name === '' ) {\n            this.unnamedAtrule(node, token);\n        }\n        this.init(node, token[2], token[3]);\n\n        let last   = false;\n        let open   = false;\n        let params = [];\n\n        this.pos += 1;\n        while ( this.pos < this.tokens.length ) {\n            token = this.tokens[this.pos];\n\n            if ( token[0] === ';' ) {\n                node.source.end = { line: token[2], column: token[3] };\n                this.semicolon = true;\n                break;\n            } else if ( token[0] === '{' ) {\n                open = true;\n                break;\n            } else if ( token[0] === '}') {\n                this.end(token);\n                break;\n            } else {\n                params.push(token);\n            }\n\n            this.pos += 1;\n        }\n        if ( this.pos === this.tokens.length ) {\n            last = true;\n        }\n\n        node.raws.between = this.spacesAndCommentsFromEnd(params);\n        if ( params.length ) {\n            node.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node, 'params', params);\n            if ( last ) {\n                token = params[params.length - 1];\n                node.source.end   = { line: token[4], column: token[5] };\n                this.spaces       = node.raws.between;\n                node.raws.between = '';\n            }\n        } else {\n            node.raws.afterName = '';\n            node.params         = '';\n        }\n\n        if ( open ) {\n            node.nodes   = [];\n            this.current = node;\n        }\n    }\n\n    end(token) {\n        if ( this.current.nodes && this.current.nodes.length ) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n\n        this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n        this.spaces = '';\n\n        if ( this.current.parent ) {\n            this.current.source.end = { line: token[2], column: token[3] };\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    }\n\n    endFile() {\n        if ( this.current.parent ) this.unclosedBlock();\n        if ( this.current.nodes && this.current.nodes.length ) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    }\n\n    // Helpers\n\n    init(node, line, column) {\n        this.current.push(node);\n\n        node.source = { start: { line, column }, input: this.input };\n        node.raws.before = this.spaces;\n        this.spaces = '';\n        if ( node.type !== 'comment' ) this.semicolon = false;\n    }\n\n    raw(node, prop, tokens) {\n        let token, type;\n        let length = tokens.length;\n        let value  = '';\n        let clean  = true;\n        for ( let i = 0; i < length; i += 1 ) {\n            token = tokens[i];\n            type  = token[0];\n            if ( type === 'comment' || type === 'space' && i === length - 1 ) {\n                clean = false;\n            } else {\n                value += token[1];\n            }\n        }\n        if ( !clean ) {\n            let raw = tokens.reduce( (all, i) => all + i[1], '');\n            node.raws[prop] = { value, raw };\n        }\n        node[prop] = value;\n    }\n\n    spacesAndCommentsFromEnd(tokens) {\n        let lastTokenType;\n        let spaces = '';\n        while ( tokens.length ) {\n            lastTokenType = tokens[tokens.length - 1][0];\n            if ( lastTokenType !== 'space' &&\n                lastTokenType !== 'comment' ) break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    }\n\n    spacesAndCommentsFromStart(tokens) {\n        let next;\n        let spaces = '';\n        while ( tokens.length ) {\n            next = tokens[0][0];\n            if ( next !== 'space' && next !== 'comment' ) break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    }\n\n    spacesFromEnd(tokens) {\n        let lastTokenType;\n        let spaces = '';\n        while ( tokens.length ) {\n            lastTokenType = tokens[tokens.length - 1][0];\n            if ( lastTokenType !== 'space' ) break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    }\n\n    stringFrom(tokens, from) {\n        let result = '';\n        for ( let i = from; i < tokens.length; i++ ) {\n            result += tokens[i][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result;\n    }\n\n    colon(tokens) {\n        let brackets = 0;\n        let token, type, prev;\n        for ( let i = 0; i < tokens.length; i++ ) {\n            token = tokens[i];\n            type  = token[0];\n\n            if ( type === '(' ) {\n                brackets += 1;\n            } else if ( type === ')' ) {\n                brackets -= 1;\n            } else if ( brackets === 0 && type === ':' ) {\n                if ( !prev ) {\n                    this.doubleColon(token);\n                } else if ( prev[0] === 'word' && prev[1] === 'progid' ) {\n                    continue;\n                } else {\n                    return i;\n                }\n            }\n\n            prev = token;\n        }\n        return false;\n    }\n\n    // Errors\n\n    unclosedBracket(bracket) {\n        throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n    }\n\n    unknownWord(start) {\n        let token = this.tokens[start];\n        throw this.input.error('Unknown word', token[2], token[3]);\n    }\n\n    unexpectedClose(token) {\n        throw this.input.error('Unexpected }', token[2], token[3]);\n    }\n\n    unclosedBlock() {\n        let pos = this.current.source.start;\n        throw this.input.error('Unclosed block', pos.line, pos.column);\n    }\n\n    doubleColon(token) {\n        throw this.input.error('Double colon', token[2], token[3]);\n    }\n\n    unnamedAtrule(node, token) {\n        throw this.input.error('At-rule without name', token[2], token[3]);\n    }\n\n    precheckMissedSemicolon(tokens) {\n        // Hook for Safe Parser\n        tokens;\n    }\n\n    checkMissedSemicolon(tokens) {\n        let colon = this.colon(tokens);\n        if ( colon === false ) return;\n\n        let founded = 0;\n        let token;\n        for ( let j = colon - 1; j >= 0; j-- ) {\n            token = tokens[j];\n            if ( token[0] !== 'space' ) {\n                founded += 1;\n                if ( founded === 2 ) break;\n            }\n        }\n        throw this.input.error('Missed semicolon', token[2], token[3]);\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}