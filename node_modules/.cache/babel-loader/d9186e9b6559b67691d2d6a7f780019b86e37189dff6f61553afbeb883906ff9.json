{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _WHITESPACE_TOKENS, _extends2;\nvar _indexesOf = require('indexes-of');\nvar _indexesOf2 = _interopRequireDefault(_indexesOf);\nvar _uniq = require('uniq');\nvar _uniq2 = _interopRequireDefault(_uniq);\nvar _root = require('./selectors/root');\nvar _root2 = _interopRequireDefault(_root);\nvar _selector = require('./selectors/selector');\nvar _selector2 = _interopRequireDefault(_selector);\nvar _className = require('./selectors/className');\nvar _className2 = _interopRequireDefault(_className);\nvar _comment = require('./selectors/comment');\nvar _comment2 = _interopRequireDefault(_comment);\nvar _id = require('./selectors/id');\nvar _id2 = _interopRequireDefault(_id);\nvar _tag = require('./selectors/tag');\nvar _tag2 = _interopRequireDefault(_tag);\nvar _string = require('./selectors/string');\nvar _string2 = _interopRequireDefault(_string);\nvar _pseudo = require('./selectors/pseudo');\nvar _pseudo2 = _interopRequireDefault(_pseudo);\nvar _attribute = require('./selectors/attribute');\nvar _attribute2 = _interopRequireDefault(_attribute);\nvar _universal = require('./selectors/universal');\nvar _universal2 = _interopRequireDefault(_universal);\nvar _combinator = require('./selectors/combinator');\nvar _combinator2 = _interopRequireDefault(_combinator);\nvar _nesting = require('./selectors/nesting');\nvar _nesting2 = _interopRequireDefault(_nesting);\nvar _sortAscending = require('./sortAscending');\nvar _sortAscending2 = _interopRequireDefault(_sortAscending);\nvar _tokenize = require('./tokenize');\nvar _tokenize2 = _interopRequireDefault(_tokenize);\nvar _tokenTypes = require('./tokenTypes');\nvar tokens = _interopRequireWildcard(_tokenTypes);\nvar _types = require('./selectors/types');\nvar types = _interopRequireWildcard(_types);\nvar _util = require('./util');\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\nvar WHITESPACE_EQUIV_TOKENS = _extends({}, WHITESPACE_TOKENS, (_extends2 = {}, _extends2[tokens.comment] = true, _extends2));\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n  if (typeof value !== \"string\") {\n    return;\n  }\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n  return node;\n}\nvar Parser = function () {\n  function Parser(rule) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Parser);\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize2.default)({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root2.default({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector2.default({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n  Parser.prototype._errorGenerator = function _errorGenerator() {\n    var _this = this;\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n  Parser.prototype.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n          if (this.options.lossy) {\n            break;\n          }\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n          break;\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n            lastAdded = 'namespace';\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n            break;\n          }\n        // Falls through\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals &&\n          // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n            node.attribute = (node.attribute || \"\") + content;\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n            lastAdded = 'attribute';\n          } else if (!node.value || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n            var _unescaped = (0, _util.unesc)(content);\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n            if (node.value && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n              lastAdded = 'insensitive';\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value) {\n              lastAdded = 'value';\n              node.value += content;\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error('Expected an attribute followed by an operator preceding the string.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n            unescaped = _unescapeValue.unescaped,\n            quoteMark = _unescapeValue.quoteMark;\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n          break;\n        default:\n          return this.error('Unexpected \"' + content + '\" found.', {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n      pos++;\n    }\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute2.default(node));\n    this.position++;\n  };\n\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */\n\n  Parser.prototype.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n        lastComment = new _comment2.default({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string2.default({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n    return nodes;\n  };\n\n  /**\n   * \n   * @param {*} nodes \n   */\n\n  Parser.prototype.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes) {\n    var _this2 = this;\n    var requiredSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n  Parser.prototype.isNamedCombinator = function isNamedCombinator() {\n    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.position;\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n  Parser.prototype.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n      if (name !== nameRaw) {\n        raws.value = '/' + nameRaw + '/';\n      }\n      var node = new _combinator2.default({\n        value: '/' + name + '/',\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n  Parser.prototype.combinator = function combinator() {\n    var _this3 = this;\n    if (this.content() === '|') {\n      return this.namespace();\n    }\n    // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n      if (nodes.length > 0) {\n        var last = this.current.last;\n        if (last) {\n          var _convertWhitespaceNod = this.convertWhitespaceNodesToSpace(nodes),\n            space = _convertWhitespaceNod.space,\n            rawSpace = _convertWhitespaceNod.rawSpace;\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n      return;\n    }\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n    var node = void 0;\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator2.default({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n      // pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _convertWhitespaceNod2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n          _space = _convertWhitespaceNod2.space,\n          _rawSpace = _convertWhitespaceNod2.rawSpace;\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _convertWhitespaceNod3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n        _space2 = _convertWhitespaceNod3.space,\n        _rawSpace2 = _convertWhitespaceNod3.rawSpace;\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n      node = new _combinator2.default({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n    return this.newNode(node);\n  };\n  Parser.prototype.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n    this.current._inferEndPosition();\n    var selector = new _selector2.default({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n  Parser.prototype.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment2.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n  Parser.prototype.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n  Parser.prototype.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n  Parser.prototype.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  Parser.prototype.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  Parser.prototype.unexpected = function unexpected() {\n    return this.error('Unexpected \\'' + this.content() + '\\'. Escaping special characters with \\\\ may help.', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  Parser.prototype.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n  };\n  Parser.prototype.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n    var current = this.currToken;\n    this.newNode(new _nesting2.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n  Parser.prototype.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector2.default({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd = void 0;\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string2.default({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n  Parser.prototype.pseudo = function pseudo() {\n    var _this4 = this;\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n        _this4.newNode(new _pseudo2.default({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n  Parser.prototype.space = function space() {\n    var content = this.content();\n    // Handle space before and after the selector\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n  Parser.prototype.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string2.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n  Parser.prototype.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n    var current = this.currToken;\n    this.newNode(new _universal2.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n  Parser.prototype.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n    var nextToken = this.nextToken;\n    var word = this.content();\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n      nextToken = this.nextToken;\n    }\n    var hasClass = (0, _indexesOf2.default)(word, '.').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    });\n    var hasId = (0, _indexesOf2.default)(word, '#');\n    // Eliminate Sass interpolations from the list of id indexes\n    var interpolations = (0, _indexesOf2.default)(word, '#{');\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n    var indices = (0, _sortAscending2.default)((0, _uniq2.default)([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n      var node = void 0;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className2.default(unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id2.default(unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag2.default(tagOpts);\n      }\n      _this5.newNode(node, namespace);\n      // Ensure that the namespace is used only once\n      namespace = null;\n    });\n    this.position++;\n  };\n  Parser.prototype.word = function word(namespace) {\n    var nextToken = this.nextToken;\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n    return this.splitWord(namespace);\n  };\n  Parser.prototype.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n    this.current._inferEndPosition();\n    return this.root;\n  };\n  Parser.prototype.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n      case tokens.comment:\n        this.comment();\n        break;\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n        break;\n      case tokens.openSquare:\n        this.attribute();\n        break;\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n      case tokens.colon:\n        this.pseudo();\n        break;\n      case tokens.comma:\n        this.comma();\n        break;\n      case tokens.asterisk:\n        this.universal();\n        break;\n      case tokens.ampersand:\n        this.nesting();\n        break;\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n      case tokens.semicolon:\n        this.missingBackslash();\n      default:\n        this.unexpected();\n    }\n  };\n\n  /**\n   * Helpers\n   */\n\n  Parser.prototype.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + ' or ' + last;\n    }\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n    if (!found) {\n      return this.error('Expected ' + an + ' ' + description + '.', {\n        index: index\n      });\n    }\n    return this.error('Expected ' + an + ' ' + description + ', found \"' + found + '\" instead.', {\n      index: index\n    });\n  };\n  Parser.prototype.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n  Parser.prototype.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n  Parser.prototype.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n  Parser.prototype.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n  Parser.prototype.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n        namespace = true;\n      }\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n    return this.current.append(node);\n  };\n  Parser.prototype.content = function content() {\n    var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currToken;\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n  Parser.prototype.locateNextMeaningfulToken = function locateNextMeaningfulToken() {\n    var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.position + 1;\n    var searchPosition = startPosition;\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n    return -1;\n  };\n  _createClass(Parser, [{\n    key: 'currToken',\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: 'nextToken',\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: 'prevToken',\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n  return Parser;\n}();\nexports.default = Parser;\nmodule.exports = exports['default'];","map":{"version":3,"names":["exports","__esModule","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_extends","assign","arguments","source","hasOwnProperty","call","_WHITESPACE_TOKENS","_extends2","_indexesOf","require","_indexesOf2","_interopRequireDefault","_uniq","_uniq2","_root","_root2","_selector","_selector2","_className","_className2","_comment","_comment2","_id","_id2","_tag","_tag2","_string","_string2","_pseudo","_pseudo2","_attribute","_attribute2","_universal","_universal2","_combinator","_combinator2","_nesting","_nesting2","_sortAscending","_sortAscending2","_tokenize","_tokenize2","_tokenTypes","tokens","_interopRequireWildcard","_types","types","_util","obj","newObj","default","_classCallCheck","instance","TypeError","WHITESPACE_TOKENS","space","cr","feed","newline","tab","WHITESPACE_EQUIV_TOKENS","comment","tokenStart","token","line","FIELDS","START_LINE","column","START_COL","tokenEnd","END_LINE","END_COL","getSource","startLine","startColumn","endLine","endColumn","start","end","getTokenSource","getTokenSourceSpan","startToken","endToken","undefined","unescapeProp","node","prop","value","indexOf","ensureObject","unesc","raws","Parser","rule","options","lossy","safe","position","css","selector","error","_errorGenerator","rootSource","root","errorGenerator","append","current","loop","_this","message","errorOptions","Error","attribute","attr","startingToken","currToken","TYPE","closeSquare","push","expected","START_POS","len","sourceIndex","word","pos","spaceBefore","commentBefore","lastAdded","spaceAfterMeaningfulToken","content","next","prevContent","spaces","after","existingComment","getProp","asterisk","equals","operator","namespace","before","rawValue","dollar","oldRawValue","caret","combinator","_rawValue","_unescaped","_oldRawValue","oldValue","quoteMark","insensitive","insensitiveFlag","str","index","_unescapeValue","unescapeValue","unescaped","lastComment","rawLastComment","lastValue","rawLastValue","newNode","parseWhitespaceEquivalentTokens","stopPosition","startPosition","nodes","firstToken","lastToken","convertWhitespaceNodesToSpace","_this2","requiredSpace","rawSpace","forEach","n","lossySpace","rawSpaceBefore","rawSpaceAfter","result","isNamedCombinator","slash","namedCombinator","nameRaw","name","toLowerCase","unexpected","_this3","nextSigTokenPos","locateNextMeaningfulToken","comma","last","_convertWhitespaceNod","spaceOrDescendantSelectorNodes","_convertWhitespaceNod2","_space","_rawSpace","_convertWhitespaceNod3","_space2","_rawSpace2","endsWith","slice","startsWith","optionalSpace","trailingComma","_inferEndPosition","parent","opts","missingBackslash","missingParenthesis","missingSquareBracket","prevToken","nextToken","universal","nesting","nextContent","parentheses","unbalanced","type","PSEUDO","cache","openParenthesis","closeParenthesis","parse","parenStart","parenValue","parenEnd","parseParenthesisToken","appendToPropertyAndEscape","pseudo","_this4","pseudoStr","colon","splitWord","first","string","firstCallback","_this5","lastIndexOf","hasClass","filter","hasId","interpolations","hashIndex","indices","concat","ind","classNameOpts","idOpts","tagOpts","throwOnParenthesis","openSquare","ampersand","semicolon","description","found","Array","isArray","pop","join","an","test","required","END_POS","searchPosition","get","module"],"sources":["C:/Users/Francisco/Documents/GitHub/examenApi/EXAMEN-API-NOTICIAS/node_modules/tailwindcss/node_modules/postcss-selector-parser/dist/parser.js"],"sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _WHITESPACE_TOKENS, _extends2;\n\nvar _indexesOf = require('indexes-of');\n\nvar _indexesOf2 = _interopRequireDefault(_indexesOf);\n\nvar _uniq = require('uniq');\n\nvar _uniq2 = _interopRequireDefault(_uniq);\n\nvar _root = require('./selectors/root');\n\nvar _root2 = _interopRequireDefault(_root);\n\nvar _selector = require('./selectors/selector');\n\nvar _selector2 = _interopRequireDefault(_selector);\n\nvar _className = require('./selectors/className');\n\nvar _className2 = _interopRequireDefault(_className);\n\nvar _comment = require('./selectors/comment');\n\nvar _comment2 = _interopRequireDefault(_comment);\n\nvar _id = require('./selectors/id');\n\nvar _id2 = _interopRequireDefault(_id);\n\nvar _tag = require('./selectors/tag');\n\nvar _tag2 = _interopRequireDefault(_tag);\n\nvar _string = require('./selectors/string');\n\nvar _string2 = _interopRequireDefault(_string);\n\nvar _pseudo = require('./selectors/pseudo');\n\nvar _pseudo2 = _interopRequireDefault(_pseudo);\n\nvar _attribute = require('./selectors/attribute');\n\nvar _attribute2 = _interopRequireDefault(_attribute);\n\nvar _universal = require('./selectors/universal');\n\nvar _universal2 = _interopRequireDefault(_universal);\n\nvar _combinator = require('./selectors/combinator');\n\nvar _combinator2 = _interopRequireDefault(_combinator);\n\nvar _nesting = require('./selectors/nesting');\n\nvar _nesting2 = _interopRequireDefault(_nesting);\n\nvar _sortAscending = require('./sortAscending');\n\nvar _sortAscending2 = _interopRequireDefault(_sortAscending);\n\nvar _tokenize = require('./tokenize');\n\nvar _tokenize2 = _interopRequireDefault(_tokenize);\n\nvar _tokenTypes = require('./tokenTypes');\n\nvar tokens = _interopRequireWildcard(_tokenTypes);\n\nvar _types = require('./selectors/types');\n\nvar types = _interopRequireWildcard(_types);\n\nvar _util = require('./util');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\n\nvar WHITESPACE_EQUIV_TOKENS = _extends({}, WHITESPACE_TOKENS, (_extends2 = {}, _extends2[tokens.comment] = true, _extends2));\n\nfunction tokenStart(token) {\n    return {\n        line: token[_tokenize.FIELDS.START_LINE],\n        column: token[_tokenize.FIELDS.START_COL]\n    };\n}\n\nfunction tokenEnd(token) {\n    return {\n        line: token[_tokenize.FIELDS.END_LINE],\n        column: token[_tokenize.FIELDS.END_COL]\n    };\n}\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n    return {\n        start: {\n            line: startLine,\n            column: startColumn\n        },\n        end: {\n            line: endLine,\n            column: endColumn\n        }\n    };\n}\n\nfunction getTokenSource(token) {\n    return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\n\nfunction getTokenSourceSpan(startToken, endToken) {\n    if (!startToken) {\n        return undefined;\n    }\n    return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\n\nfunction unescapeProp(node, prop) {\n    var value = node[prop];\n    if (typeof value !== \"string\") {\n        return;\n    }\n    if (value.indexOf(\"\\\\\") !== -1) {\n        (0, _util.ensureObject)(node, 'raws');\n        node[prop] = (0, _util.unesc)(value);\n        if (node.raws[prop] === undefined) {\n            node.raws[prop] = value;\n        }\n    }\n    return node;\n}\n\nvar Parser = function () {\n    function Parser(rule) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, Parser);\n\n        this.rule = rule;\n        this.options = Object.assign({ lossy: false, safe: false }, options);\n        this.position = 0;\n\n        this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n\n        this.tokens = (0, _tokenize2.default)({\n            css: this.css,\n            error: this._errorGenerator(),\n            safe: this.options.safe\n        });\n\n        var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n        this.root = new _root2.default({ source: rootSource });\n        this.root.errorGenerator = this._errorGenerator();\n\n        var selector = new _selector2.default({ source: { start: { line: 1, column: 1 } } });\n        this.root.append(selector);\n        this.current = selector;\n\n        this.loop();\n    }\n\n    Parser.prototype._errorGenerator = function _errorGenerator() {\n        var _this = this;\n\n        return function (message, errorOptions) {\n            if (typeof _this.rule === 'string') {\n                return new Error(message);\n            }\n            return _this.rule.error(message, errorOptions);\n        };\n    };\n\n    Parser.prototype.attribute = function attribute() {\n        var attr = [];\n        var startingToken = this.currToken;\n        this.position++;\n        while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n            attr.push(this.currToken);\n            this.position++;\n        }\n        if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n            return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n        }\n\n        var len = attr.length;\n        var node = {\n            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        };\n\n        if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n            return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n        }\n\n        var pos = 0;\n        var spaceBefore = '';\n        var commentBefore = '';\n        var lastAdded = null;\n        var spaceAfterMeaningfulToken = false;\n\n        while (pos < len) {\n            var token = attr[pos];\n            var content = this.content(token);\n            var next = attr[pos + 1];\n\n            switch (token[_tokenize.FIELDS.TYPE]) {\n                case tokens.space:\n                    // if (\n                    //     len === 1 ||\n                    //     pos === 0 && this.content(next) === '|'\n                    // ) {\n                    //     return this.expected('attribute', token[TOKEN.START_POS], content);\n                    // }\n                    spaceAfterMeaningfulToken = true;\n                    if (this.options.lossy) {\n                        break;\n                    }\n                    if (lastAdded) {\n                        (0, _util.ensureObject)(node, 'spaces', lastAdded);\n                        var prevContent = node.spaces[lastAdded].after || '';\n                        node.spaces[lastAdded].after = prevContent + content;\n\n                        var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n                        if (existingComment) {\n                            node.raws.spaces[lastAdded].after = existingComment + content;\n                        }\n                    } else {\n                        spaceBefore = spaceBefore + content;\n                        commentBefore = commentBefore + content;\n                    }\n                    break;\n                case tokens.asterisk:\n                    if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n                        node.operator = content;\n                        lastAdded = 'operator';\n                    } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n                        if (spaceBefore) {\n                            (0, _util.ensureObject)(node, 'spaces', 'attribute');\n                            node.spaces.attribute.before = spaceBefore;\n                            spaceBefore = '';\n                        }\n                        if (commentBefore) {\n                            (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n                            node.raws.spaces.attribute.before = spaceBefore;\n                            commentBefore = '';\n                        }\n                        node.namespace = (node.namespace || \"\") + content;\n                        var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n                        if (rawValue) {\n                            node.raws.namespace += content;\n                        }\n                        lastAdded = 'namespace';\n                    }\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.dollar:\n                    if (lastAdded === \"value\") {\n                        var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n                        node.value += \"$\";\n                        if (oldRawValue) {\n                            node.raws.value = oldRawValue + \"$\";\n                        }\n                        break;\n                    }\n                // Falls through\n                case tokens.caret:\n                    if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n                        node.operator = content;\n                        lastAdded = 'operator';\n                    }\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.combinator:\n                    if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n                        node.operator = content;\n                        lastAdded = 'operator';\n                    }\n                    if (content !== '|') {\n                        spaceAfterMeaningfulToken = false;\n                        break;\n                    }\n                    if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n                        node.operator = content;\n                        lastAdded = 'operator';\n                    } else if (!node.namespace && !node.attribute) {\n                        node.namespace = true;\n                    }\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.word:\n                    if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n                    !node.operator && !node.namespace) {\n                        node.namespace = content;\n                        lastAdded = 'namespace';\n                    } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n                        if (spaceBefore) {\n                            (0, _util.ensureObject)(node, 'spaces', 'attribute');\n                            node.spaces.attribute.before = spaceBefore;\n\n                            spaceBefore = '';\n                        }\n                        if (commentBefore) {\n                            (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n                            node.raws.spaces.attribute.before = commentBefore;\n                            commentBefore = '';\n                        }\n                        node.attribute = (node.attribute || \"\") + content;\n                        var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n                        if (_rawValue) {\n                            node.raws.attribute += content;\n                        }\n                        lastAdded = 'attribute';\n                    } else if (!node.value || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n                        var _unescaped = (0, _util.unesc)(content);\n                        var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n                        var oldValue = node.value || '';\n                        node.value = oldValue + _unescaped;\n                        node.quoteMark = null;\n                        if (_unescaped !== content || _oldRawValue) {\n                            (0, _util.ensureObject)(node, 'raws');\n                            node.raws.value = (_oldRawValue || oldValue) + content;\n                        }\n                        lastAdded = 'value';\n                    } else {\n                        var insensitive = content === 'i' || content === \"I\";\n                        if (node.value && (node.quoteMark || spaceAfterMeaningfulToken)) {\n                            node.insensitive = insensitive;\n                            if (!insensitive || content === \"I\") {\n                                (0, _util.ensureObject)(node, 'raws');\n                                node.raws.insensitiveFlag = content;\n                            }\n                            lastAdded = 'insensitive';\n                            if (spaceBefore) {\n                                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                                node.spaces.insensitive.before = spaceBefore;\n\n                                spaceBefore = '';\n                            }\n                            if (commentBefore) {\n                                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                                node.raws.spaces.insensitive.before = commentBefore;\n                                commentBefore = '';\n                            }\n                        } else if (node.value) {\n                            lastAdded = 'value';\n                            node.value += content;\n                            if (node.raws.value) {\n                                node.raws.value += content;\n                            }\n                        }\n                    }\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.str:\n                    if (!node.attribute || !node.operator) {\n                        return this.error('Expected an attribute followed by an operator preceding the string.', {\n                            index: token[_tokenize.FIELDS.START_POS]\n                        });\n                    }\n\n                    var _unescapeValue = (0, _attribute.unescapeValue)(content),\n                        unescaped = _unescapeValue.unescaped,\n                        quoteMark = _unescapeValue.quoteMark;\n\n                    node.value = unescaped;\n                    node.quoteMark = quoteMark;\n                    lastAdded = 'value';\n\n                    (0, _util.ensureObject)(node, 'raws');\n                    node.raws.value = content;\n\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.equals:\n                    if (!node.attribute) {\n                        return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n                    }\n                    if (node.value) {\n                        return this.error('Unexpected \"=\" found; an operator was already defined.', { index: token[_tokenize.FIELDS.START_POS] });\n                    }\n                    node.operator = node.operator ? node.operator + content : content;\n                    lastAdded = 'operator';\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.comment:\n                    if (lastAdded) {\n                        if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n                            var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n                            var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n\n                            (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n                            node.raws.spaces[lastAdded].after = rawLastComment + content;\n                        } else {\n                            var lastValue = node[lastAdded] || '';\n                            var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n                            (0, _util.ensureObject)(node, 'raws');\n                            node.raws[lastAdded] = rawLastValue + content;\n                        }\n                    } else {\n                        commentBefore = commentBefore + content;\n                    }\n                    break;\n                default:\n                    return this.error('Unexpected \"' + content + '\" found.', { index: token[_tokenize.FIELDS.START_POS] });\n            }\n            pos++;\n        }\n        unescapeProp(node, \"attribute\");\n        unescapeProp(node, \"namespace\");\n        this.newNode(new _attribute2.default(node));\n        this.position++;\n    };\n\n    /**\n     * return a node containing meaningless garbage up to (but not including) the specified token position.\n     * if the token position is negative, all remaining tokens are consumed.\n     *\n     * This returns an array containing a single string node if all whitespace,\n     * otherwise an array of comment nodes with space before and after.\n     *\n     * These tokens are not added to the current selector, the caller can add them or use them to amend\n     * a previous node's space metadata.\n     *\n     * In lossy mode, this returns only comments.\n     */\n\n\n    Parser.prototype.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n        if (stopPosition < 0) {\n            stopPosition = this.tokens.length;\n        }\n        var startPosition = this.position;\n        var nodes = [];\n        var space = \"\";\n        var lastComment = undefined;\n        do {\n            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n                if (!this.options.lossy) {\n                    space += this.content();\n                }\n            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n                var spaces = {};\n                if (space) {\n                    spaces.before = space;\n                    space = \"\";\n                }\n                lastComment = new _comment2.default({\n                    value: this.content(),\n                    source: getTokenSource(this.currToken),\n                    sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n                    spaces: spaces\n                });\n                nodes.push(lastComment);\n            }\n        } while (++this.position < stopPosition);\n\n        if (space) {\n            if (lastComment) {\n                lastComment.spaces.after = space;\n            } else if (!this.options.lossy) {\n                var firstToken = this.tokens[startPosition];\n                var lastToken = this.tokens[this.position - 1];\n                nodes.push(new _string2.default({\n                    value: '',\n                    source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n                    sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n                    spaces: { before: space, after: '' }\n                }));\n            }\n        }\n        return nodes;\n    };\n\n    /**\n     * \n     * @param {*} nodes \n     */\n\n\n    Parser.prototype.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes) {\n        var _this2 = this;\n\n        var requiredSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        var space = \"\";\n        var rawSpace = \"\";\n        nodes.forEach(function (n) {\n            var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n            var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n            space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n            rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n        });\n        if (rawSpace === space) {\n            rawSpace = undefined;\n        }\n        var result = { space: space, rawSpace: rawSpace };\n        return result;\n    };\n\n    Parser.prototype.isNamedCombinator = function isNamedCombinator() {\n        var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.position;\n\n        return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n    };\n\n    Parser.prototype.namedCombinator = function namedCombinator() {\n        if (this.isNamedCombinator()) {\n            var nameRaw = this.content(this.tokens[this.position + 1]);\n            var name = (0, _util.unesc)(nameRaw).toLowerCase();\n            var raws = {};\n            if (name !== nameRaw) {\n                raws.value = '/' + nameRaw + '/';\n            }\n            var node = new _combinator2.default({\n                value: '/' + name + '/',\n                source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n                raws: raws\n            });\n            this.position = this.position + 3;\n            return node;\n        } else {\n            this.unexpected();\n        }\n    };\n\n    Parser.prototype.combinator = function combinator() {\n        var _this3 = this;\n\n        if (this.content() === '|') {\n            return this.namespace();\n        }\n        // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n        var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n            if (nodes.length > 0) {\n                var last = this.current.last;\n                if (last) {\n                    var _convertWhitespaceNod = this.convertWhitespaceNodesToSpace(nodes),\n                        space = _convertWhitespaceNod.space,\n                        rawSpace = _convertWhitespaceNod.rawSpace;\n\n                    if (rawSpace !== undefined) {\n                        last.rawSpaceAfter += rawSpace;\n                    }\n                    last.spaces.after += space;\n                } else {\n                    nodes.forEach(function (n) {\n                        return _this3.newNode(n);\n                    });\n                }\n            }\n            return;\n        }\n\n        var firstToken = this.currToken;\n        var spaceOrDescendantSelectorNodes = undefined;\n        if (nextSigTokenPos > this.position) {\n            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n        }\n\n        var node = void 0;\n        if (this.isNamedCombinator()) {\n            node = this.namedCombinator();\n        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n            node = new _combinator2.default({\n                value: this.content(),\n                source: getTokenSource(this.currToken),\n                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n            });\n            this.position++;\n        } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n            // pass\n        } else if (!spaceOrDescendantSelectorNodes) {\n            this.unexpected();\n        }\n\n        if (node) {\n            if (spaceOrDescendantSelectorNodes) {\n                var _convertWhitespaceNod2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n                    _space = _convertWhitespaceNod2.space,\n                    _rawSpace = _convertWhitespaceNod2.rawSpace;\n\n                node.spaces.before = _space;\n                node.rawSpaceBefore = _rawSpace;\n            }\n        } else {\n            // descendant combinator\n            var _convertWhitespaceNod3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n                _space2 = _convertWhitespaceNod3.space,\n                _rawSpace2 = _convertWhitespaceNod3.rawSpace;\n\n            if (!_rawSpace2) {\n                _rawSpace2 = _space2;\n            }\n            var spaces = {};\n            var raws = { spaces: {} };\n            if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n                spaces.before = _space2.slice(0, _space2.length - 1);\n                raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n            } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n                spaces.after = _space2.slice(1);\n                raws.spaces.after = _rawSpace2.slice(1);\n            } else {\n                raws.value = _rawSpace2;\n            }\n            node = new _combinator2.default({\n                value: ' ',\n                source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n                spaces: spaces,\n                raws: raws\n            });\n        }\n\n        if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n            node.spaces.after = this.optionalSpace(this.content());\n            this.position++;\n        }\n\n        return this.newNode(node);\n    };\n\n    Parser.prototype.comma = function comma() {\n        if (this.position === this.tokens.length - 1) {\n            this.root.trailingComma = true;\n            this.position++;\n            return;\n        }\n        this.current._inferEndPosition();\n        var selector = new _selector2.default({ source: { start: tokenStart(this.tokens[this.position + 1]) } });\n        this.current.parent.append(selector);\n        this.current = selector;\n        this.position++;\n    };\n\n    Parser.prototype.comment = function comment() {\n        var current = this.currToken;\n        this.newNode(new _comment2.default({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[_tokenize.FIELDS.START_POS]\n        }));\n        this.position++;\n    };\n\n    Parser.prototype.error = function error(message, opts) {\n        throw this.root.error(message, opts);\n    };\n\n    Parser.prototype.missingBackslash = function missingBackslash() {\n        return this.error('Expected a backslash preceding the semicolon.', {\n            index: this.currToken[_tokenize.FIELDS.START_POS]\n        });\n    };\n\n    Parser.prototype.missingParenthesis = function missingParenthesis() {\n        return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    };\n\n    Parser.prototype.missingSquareBracket = function missingSquareBracket() {\n        return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    };\n\n    Parser.prototype.unexpected = function unexpected() {\n        return this.error('Unexpected \\'' + this.content() + '\\'. Escaping special characters with \\\\ may help.', this.currToken[_tokenize.FIELDS.START_POS]);\n    };\n\n    Parser.prototype.namespace = function namespace() {\n        var before = this.prevToken && this.content(this.prevToken) || true;\n        if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n            this.position++;\n            return this.word(before);\n        } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n            this.position++;\n            return this.universal(before);\n        }\n    };\n\n    Parser.prototype.nesting = function nesting() {\n        if (this.nextToken) {\n            var nextContent = this.content(this.nextToken);\n            if (nextContent === \"|\") {\n                this.position++;\n                return;\n            }\n        }\n        var current = this.currToken;\n        this.newNode(new _nesting2.default({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[_tokenize.FIELDS.START_POS]\n        }));\n        this.position++;\n    };\n\n    Parser.prototype.parentheses = function parentheses() {\n        var last = this.current.last;\n        var unbalanced = 1;\n        this.position++;\n        if (last && last.type === types.PSEUDO) {\n            var selector = new _selector2.default({ source: { start: tokenStart(this.tokens[this.position - 1]) } });\n            var cache = this.current;\n            last.append(selector);\n            this.current = selector;\n            while (this.position < this.tokens.length && unbalanced) {\n                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n                    unbalanced++;\n                }\n                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n                    unbalanced--;\n                }\n                if (unbalanced) {\n                    this.parse();\n                } else {\n                    this.current.source.end = tokenEnd(this.currToken);\n                    this.current.parent.source.end = tokenEnd(this.currToken);\n                    this.position++;\n                }\n            }\n            this.current = cache;\n        } else {\n            // I think this case should be an error. It's used to implement a basic parse of media queries\n            // but I don't think it's a good idea.\n            var parenStart = this.currToken;\n            var parenValue = \"(\";\n            var parenEnd = void 0;\n            while (this.position < this.tokens.length && unbalanced) {\n                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n                    unbalanced++;\n                }\n                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n                    unbalanced--;\n                }\n                parenEnd = this.currToken;\n                parenValue += this.parseParenthesisToken(this.currToken);\n                this.position++;\n            }\n            if (last) {\n                last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n            } else {\n                this.newNode(new _string2.default({\n                    value: parenValue,\n                    source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n                    sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n                }));\n            }\n        }\n        if (unbalanced) {\n            return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n        }\n    };\n\n    Parser.prototype.pseudo = function pseudo() {\n        var _this4 = this;\n\n        var pseudoStr = '';\n        var startingToken = this.currToken;\n        while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n            pseudoStr += this.content();\n            this.position++;\n        }\n        if (!this.currToken) {\n            return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n        }\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n            this.splitWord(false, function (first, length) {\n                pseudoStr += first;\n                _this4.newNode(new _pseudo2.default({\n                    value: pseudoStr,\n                    source: getTokenSourceSpan(startingToken, _this4.currToken),\n                    sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n                }));\n                if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n                    _this4.error('Misplaced parenthesis.', {\n                        index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n                    });\n                }\n            });\n        } else {\n            return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n        }\n    };\n\n    Parser.prototype.space = function space() {\n        var content = this.content();\n        // Handle space before and after the selector\n        if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n            this.spaces = this.optionalSpace(content);\n            this.position++;\n        } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n            this.current.last.spaces.after = this.optionalSpace(content);\n            this.position++;\n        } else {\n            this.combinator();\n        }\n    };\n\n    Parser.prototype.string = function string() {\n        var current = this.currToken;\n        this.newNode(new _string2.default({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[_tokenize.FIELDS.START_POS]\n        }));\n        this.position++;\n    };\n\n    Parser.prototype.universal = function universal(namespace) {\n        var nextToken = this.nextToken;\n        if (nextToken && this.content(nextToken) === '|') {\n            this.position++;\n            return this.namespace();\n        }\n        var current = this.currToken;\n        this.newNode(new _universal2.default({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[_tokenize.FIELDS.START_POS]\n        }), namespace);\n        this.position++;\n    };\n\n    Parser.prototype.splitWord = function splitWord(namespace, firstCallback) {\n        var _this5 = this;\n\n        var nextToken = this.nextToken;\n        var word = this.content();\n        while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n            this.position++;\n            var current = this.content();\n            word += current;\n            if (current.lastIndexOf('\\\\') === current.length - 1) {\n                var next = this.nextToken;\n                if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n                    word += this.requiredSpace(this.content(next));\n                    this.position++;\n                }\n            }\n            nextToken = this.nextToken;\n        }\n        var hasClass = (0, _indexesOf2.default)(word, '.').filter(function (i) {\n            return word[i - 1] !== '\\\\';\n        });\n        var hasId = (0, _indexesOf2.default)(word, '#');\n        // Eliminate Sass interpolations from the list of id indexes\n        var interpolations = (0, _indexesOf2.default)(word, '#{');\n        if (interpolations.length) {\n            hasId = hasId.filter(function (hashIndex) {\n                return !~interpolations.indexOf(hashIndex);\n            });\n        }\n        var indices = (0, _sortAscending2.default)((0, _uniq2.default)([0].concat(hasClass, hasId)));\n        indices.forEach(function (ind, i) {\n            var index = indices[i + 1] || word.length;\n            var value = word.slice(ind, index);\n            if (i === 0 && firstCallback) {\n                return firstCallback.call(_this5, value, indices.length);\n            }\n            var node = void 0;\n            var current = _this5.currToken;\n            var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n            var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n            if (~hasClass.indexOf(ind)) {\n                var classNameOpts = {\n                    value: value.slice(1),\n                    source: source,\n                    sourceIndex: sourceIndex\n                };\n                node = new _className2.default(unescapeProp(classNameOpts, \"value\"));\n            } else if (~hasId.indexOf(ind)) {\n                var idOpts = {\n                    value: value.slice(1),\n                    source: source,\n                    sourceIndex: sourceIndex\n                };\n                node = new _id2.default(unescapeProp(idOpts, \"value\"));\n            } else {\n                var tagOpts = {\n                    value: value,\n                    source: source,\n                    sourceIndex: sourceIndex\n                };\n                unescapeProp(tagOpts, \"value\");\n                node = new _tag2.default(tagOpts);\n            }\n            _this5.newNode(node, namespace);\n            // Ensure that the namespace is used only once\n            namespace = null;\n        });\n        this.position++;\n    };\n\n    Parser.prototype.word = function word(namespace) {\n        var nextToken = this.nextToken;\n        if (nextToken && this.content(nextToken) === '|') {\n            this.position++;\n            return this.namespace();\n        }\n        return this.splitWord(namespace);\n    };\n\n    Parser.prototype.loop = function loop() {\n        while (this.position < this.tokens.length) {\n            this.parse(true);\n        }\n        this.current._inferEndPosition();\n        return this.root;\n    };\n\n    Parser.prototype.parse = function parse(throwOnParenthesis) {\n        switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n            case tokens.space:\n                this.space();\n                break;\n            case tokens.comment:\n                this.comment();\n                break;\n            case tokens.openParenthesis:\n                this.parentheses();\n                break;\n            case tokens.closeParenthesis:\n                if (throwOnParenthesis) {\n                    this.missingParenthesis();\n                }\n                break;\n            case tokens.openSquare:\n                this.attribute();\n                break;\n            case tokens.dollar:\n            case tokens.caret:\n            case tokens.equals:\n            case tokens.word:\n                this.word();\n                break;\n            case tokens.colon:\n                this.pseudo();\n                break;\n            case tokens.comma:\n                this.comma();\n                break;\n            case tokens.asterisk:\n                this.universal();\n                break;\n            case tokens.ampersand:\n                this.nesting();\n                break;\n            case tokens.slash:\n            case tokens.combinator:\n                this.combinator();\n                break;\n            case tokens.str:\n                this.string();\n                break;\n            // These cases throw; no break needed.\n            case tokens.closeSquare:\n                this.missingSquareBracket();\n            case tokens.semicolon:\n                this.missingBackslash();\n            default:\n                this.unexpected();\n        }\n    };\n\n    /**\n     * Helpers\n     */\n\n    Parser.prototype.expected = function expected(description, index, found) {\n        if (Array.isArray(description)) {\n            var last = description.pop();\n            description = description.join(', ') + ' or ' + last;\n        }\n        var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n        if (!found) {\n            return this.error('Expected ' + an + ' ' + description + '.', { index: index });\n        }\n        return this.error('Expected ' + an + ' ' + description + ', found \"' + found + '\" instead.', { index: index });\n    };\n\n    Parser.prototype.requiredSpace = function requiredSpace(space) {\n        return this.options.lossy ? ' ' : space;\n    };\n\n    Parser.prototype.optionalSpace = function optionalSpace(space) {\n        return this.options.lossy ? '' : space;\n    };\n\n    Parser.prototype.lossySpace = function lossySpace(space, required) {\n        if (this.options.lossy) {\n            return required ? ' ' : '';\n        } else {\n            return space;\n        }\n    };\n\n    Parser.prototype.parseParenthesisToken = function parseParenthesisToken(token) {\n        var content = this.content(token);\n        if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n            return this.requiredSpace(content);\n        } else {\n            return content;\n        }\n    };\n\n    Parser.prototype.newNode = function newNode(node, namespace) {\n        if (namespace) {\n            if (/^ +$/.test(namespace)) {\n                if (!this.options.lossy) {\n                    this.spaces = (this.spaces || '') + namespace;\n                }\n                namespace = true;\n            }\n            node.namespace = namespace;\n            unescapeProp(node, \"namespace\");\n        }\n        if (this.spaces) {\n            node.spaces.before = this.spaces;\n            this.spaces = '';\n        }\n        return this.current.append(node);\n    };\n\n    Parser.prototype.content = function content() {\n        var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currToken;\n\n        return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n    };\n\n    /**\n     * returns the index of the next non-whitespace, non-comment token.\n     * returns -1 if no meaningful token is found.\n     */\n    Parser.prototype.locateNextMeaningfulToken = function locateNextMeaningfulToken() {\n        var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.position + 1;\n\n        var searchPosition = startPosition;\n        while (searchPosition < this.tokens.length) {\n            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n                searchPosition++;\n                continue;\n            } else {\n                return searchPosition;\n            }\n        }\n        return -1;\n    };\n\n    _createClass(Parser, [{\n        key: 'currToken',\n        get: function get() {\n            return this.tokens[this.position];\n        }\n    }, {\n        key: 'nextToken',\n        get: function get() {\n            return this.tokens[this.position + 1];\n        }\n    }, {\n        key: 'prevToken',\n        get: function get() {\n            return this.tokens[this.position - 1];\n        }\n    }]);\n\n    return Parser;\n}();\n\nexports.default = Parser;\nmodule.exports = exports['default'];"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}