{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _supportsColor = require('supports-color');\nvar _supportsColor2 = _interopRequireDefault(_supportsColor);\nvar _chalk = require('chalk');\nvar _chalk2 = _interopRequireDefault(_chalk);\nvar _terminalHighlight = require('./terminal-highlight');\nvar _terminalHighlight2 = _interopRequireDefault(_terminalHighlight);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * The CSS parser throws this error for broken CSS.\n *\n * Custom parsers can throw this error for broken custom syntax using\n * the {@link Node#error} method.\n *\n * PostCSS will use the input source map to detect the original error location.\n * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,\n * PostCSS will show the original position in the Sass file.\n *\n * If you need the position in the PostCSS input\n * (e.g., to debug the previous compiler), use `error.input.file`.\n *\n * @example\n * // Catching and checking syntax error\n * try {\n *   postcss.parse('a{')\n * } catch (error) {\n *   if ( error.name === 'CssSyntaxError' ) {\n *     error //=> CssSyntaxError\n *   }\n * }\n *\n * @example\n * // Raising error from plugin\n * throw node.error('Unknown variable', { plugin: 'postcss-vars' });\n */\nvar CssSyntaxError = function () {\n  /**\n   * @param {string} message  - error message\n   * @param {number} [line]   - source line of the error\n   * @param {number} [column] - source column of the error\n   * @param {string} [source] - source code of the broken file\n   * @param {string} [file]   - absolute path to the broken file\n   * @param {string} [plugin] - PostCSS plugin name, if error came from plugin\n   */\n  function CssSyntaxError(message, line, column, source, file, plugin) {\n    _classCallCheck(this, CssSyntaxError);\n\n    /**\n     * @member {string} - Always equal to `'CssSyntaxError'`. You should\n     *                    always check error type\n     *                    by `error.name === 'CssSyntaxError'` instead of\n     *                    `error instanceof CssSyntaxError`, because\n     *                    npm could have several PostCSS versions.\n     *\n     * @example\n     * if ( error.name === 'CssSyntaxError' ) {\n     *   error //=> CssSyntaxError\n     * }\n     */\n    this.name = 'CssSyntaxError';\n    /**\n     * @member {string} - Error message.\n     *\n     * @example\n     * error.message //=> 'Unclosed block'\n     */\n    this.reason = message;\n    if (file) {\n      /**\n       * @member {string} - Absolute path to the broken file.\n       *\n       * @example\n       * error.file       //=> 'a.sass'\n       * error.input.file //=> 'a.css'\n       */\n      this.file = file;\n    }\n    if (source) {\n      /**\n       * @member {string} - Source code of the broken file.\n       *\n       * @example\n       * error.source       //=> 'a { b {} }'\n       * error.input.column //=> 'a b { }'\n       */\n      this.source = source;\n    }\n    if (plugin) {\n      /**\n       * @member {string} - Plugin name, if error came from plugin.\n       *\n       * @example\n       * error.plugin //=> 'postcss-vars'\n       */\n      this.plugin = plugin;\n    }\n    if (typeof line !== 'undefined' && typeof column !== 'undefined') {\n      /**\n       * @member {number} - Source line of the error.\n       *\n       * @example\n       * error.line       //=> 2\n       * error.input.line //=> 4\n       */\n      this.line = line;\n      /**\n       * @member {number} - Source column of the error.\n       *\n       * @example\n       * error.column       //=> 1\n       * error.input.column //=> 4\n       */\n      this.column = column;\n    }\n    this.setMessage();\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CssSyntaxError);\n    }\n  }\n  CssSyntaxError.prototype.setMessage = function setMessage() {\n    /**\n     * @member {string} - Full error text in the GNU error format\n     *                    with plugin, file, line and column.\n     *\n     * @example\n     * error.message //=> 'a.css:1:1: Unclosed block'\n     */\n    this.message = this.plugin ? this.plugin + ': ' : '';\n    this.message += this.file ? this.file : '<css input>';\n    if (typeof this.line !== 'undefined') {\n      this.message += ':' + this.line + ':' + this.column;\n    }\n    this.message += ': ' + this.reason;\n  };\n\n  /**\n   * Returns a few lines of CSS source that caused the error.\n   *\n   * If the CSS has an input source map without `sourceContent`,\n   * this method will return an empty string.\n   *\n   * @param {boolean} [color] whether arrow will be colored red by terminal\n   *                          color codes. By default, PostCSS will detect\n   *                          color support by `process.stdout.isTTY`\n   *                          and `process.env.NODE_DISABLE_COLORS`.\n   *\n   * @example\n   * error.showSourceCode() //=> \"  4 | }\n   *                        //      5 | a {\n   *                        //    > 6 |   bad\n   *                        //        |   ^\n   *                        //      7 | }\n   *                        //      8 | b {\"\n   *\n   * @return {string} few lines of CSS source that caused the error\n   */\n\n  CssSyntaxError.prototype.showSourceCode = function showSourceCode(color) {\n    var _this = this;\n    if (!this.source) return '';\n    var css = this.source;\n    if (typeof color === 'undefined') color = _supportsColor2.default.stdout;\n    if (color) css = (0, _terminalHighlight2.default)(css);\n    var lines = css.split(/\\r?\\n/);\n    var start = Math.max(this.line - 3, 0);\n    var end = Math.min(this.line + 2, lines.length);\n    var maxWidth = String(end).length;\n    function mark(text) {\n      if (color && _chalk2.default.red) {\n        return _chalk2.default.red.bold(text);\n      } else {\n        return text;\n      }\n    }\n    function aside(text) {\n      if (color && _chalk2.default.gray) {\n        return _chalk2.default.gray(text);\n      } else {\n        return text;\n      }\n    }\n    return lines.slice(start, end).map(function (line, index) {\n      var number = start + 1 + index;\n      var gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';\n      if (number === _this.line) {\n        var spacing = aside(gutter.replace(/\\d/g, ' ')) + line.slice(0, _this.column - 1).replace(/[^\\t]/g, ' ');\n        return mark('>') + aside(gutter) + line + '\\n ' + spacing + mark('^');\n      } else {\n        return ' ' + aside(gutter) + line;\n      }\n    }).join('\\n');\n  };\n\n  /**\n   * Returns error position, message and source code of the broken part.\n   *\n   * @example\n   * error.toString() //=> \"CssSyntaxError: app.css:1:1: Unclosed block\n   *                  //    > 1 | a {\n   *                  //        | ^\"\n   *\n   * @return {string} error position, message and source code\n   */\n\n  CssSyntaxError.prototype.toString = function toString() {\n    var code = this.showSourceCode();\n    if (code) {\n      code = '\\n\\n' + code + '\\n';\n    }\n    return this.name + ': ' + this.message + code;\n  };\n\n  /**\n   * @memberof CssSyntaxError#\n   * @member {Input} input - Input object with PostCSS internal information\n   *                         about input file. If input has source map\n   *                         from previous tool, PostCSS will use origin\n   *                         (for example, Sass) source. You can use this\n   *                         object to get PostCSS input source.\n   *\n   * @example\n   * error.input.file //=> 'a.css'\n   * error.file       //=> 'a.sass'\n   */\n\n  return CssSyntaxError;\n}();\nexports.default = CssSyntaxError;\nmodule.exports = exports['default'];","map":{"version":3,"names":["_supportsColor","require","_chalk","_terminalHighlight","CssSyntaxError","message","line","column","source","file","plugin","_classCallCheck","name","reason","setMessage","Error","captureStackTrace","showSourceCode","color","_this","css","_supportsColor2","default","stdout","_terminalHighlight2","lines","split","start","Math","max","end","min","length","maxWidth","String","mark","text","_chalk2","red","bold","aside","gray","slice","map","index","number","gutter","spacing","replace","join","toString","code"],"sources":["C:\\Users\\Francisco\\Documents\\GitHub\\examenApi\\EXAMEN-API-NOTICIAS\\node_modules\\postcss-functions\\node_modules\\postcss\\lib\\css-syntax-error.es6"],"sourcesContent":["import supportsColor from 'supports-color';\nimport chalk         from 'chalk';\n\nimport terminalHighlight from './terminal-highlight';\n\n/**\n * The CSS parser throws this error for broken CSS.\n *\n * Custom parsers can throw this error for broken custom syntax using\n * the {@link Node#error} method.\n *\n * PostCSS will use the input source map to detect the original error location.\n * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,\n * PostCSS will show the original position in the Sass file.\n *\n * If you need the position in the PostCSS input\n * (e.g., to debug the previous compiler), use `error.input.file`.\n *\n * @example\n * // Catching and checking syntax error\n * try {\n *   postcss.parse('a{')\n * } catch (error) {\n *   if ( error.name === 'CssSyntaxError' ) {\n *     error //=> CssSyntaxError\n *   }\n * }\n *\n * @example\n * // Raising error from plugin\n * throw node.error('Unknown variable', { plugin: 'postcss-vars' });\n */\nclass CssSyntaxError {\n\n    /**\n     * @param {string} message  - error message\n     * @param {number} [line]   - source line of the error\n     * @param {number} [column] - source column of the error\n     * @param {string} [source] - source code of the broken file\n     * @param {string} [file]   - absolute path to the broken file\n     * @param {string} [plugin] - PostCSS plugin name, if error came from plugin\n     */\n    constructor(message, line, column, source, file, plugin) {\n        /**\n         * @member {string} - Always equal to `'CssSyntaxError'`. You should\n         *                    always check error type\n         *                    by `error.name === 'CssSyntaxError'` instead of\n         *                    `error instanceof CssSyntaxError`, because\n         *                    npm could have several PostCSS versions.\n         *\n         * @example\n         * if ( error.name === 'CssSyntaxError' ) {\n         *   error //=> CssSyntaxError\n         * }\n         */\n        this.name = 'CssSyntaxError';\n        /**\n         * @member {string} - Error message.\n         *\n         * @example\n         * error.message //=> 'Unclosed block'\n         */\n        this.reason = message;\n\n        if ( file ) {\n            /**\n             * @member {string} - Absolute path to the broken file.\n             *\n             * @example\n             * error.file       //=> 'a.sass'\n             * error.input.file //=> 'a.css'\n             */\n            this.file = file;\n        }\n        if ( source ) {\n            /**\n             * @member {string} - Source code of the broken file.\n             *\n             * @example\n             * error.source       //=> 'a { b {} }'\n             * error.input.column //=> 'a b { }'\n             */\n            this.source = source;\n        }\n        if ( plugin ) {\n            /**\n             * @member {string} - Plugin name, if error came from plugin.\n             *\n             * @example\n             * error.plugin //=> 'postcss-vars'\n             */\n            this.plugin = plugin;\n        }\n        if ( typeof line !== 'undefined' && typeof column !== 'undefined' ) {\n            /**\n             * @member {number} - Source line of the error.\n             *\n             * @example\n             * error.line       //=> 2\n             * error.input.line //=> 4\n             */\n            this.line   = line;\n            /**\n             * @member {number} - Source column of the error.\n             *\n             * @example\n             * error.column       //=> 1\n             * error.input.column //=> 4\n             */\n            this.column = column;\n        }\n\n        this.setMessage();\n\n        if ( Error.captureStackTrace ) {\n            Error.captureStackTrace(this, CssSyntaxError);\n        }\n    }\n\n    setMessage() {\n        /**\n         * @member {string} - Full error text in the GNU error format\n         *                    with plugin, file, line and column.\n         *\n         * @example\n         * error.message //=> 'a.css:1:1: Unclosed block'\n         */\n        this.message  = this.plugin ? this.plugin + ': ' : '';\n        this.message += this.file ? this.file : '<css input>';\n        if ( typeof this.line !== 'undefined' ) {\n            this.message += ':' + this.line + ':' + this.column;\n        }\n        this.message += ': ' + this.reason;\n    }\n\n    /**\n     * Returns a few lines of CSS source that caused the error.\n     *\n     * If the CSS has an input source map without `sourceContent`,\n     * this method will return an empty string.\n     *\n     * @param {boolean} [color] whether arrow will be colored red by terminal\n     *                          color codes. By default, PostCSS will detect\n     *                          color support by `process.stdout.isTTY`\n     *                          and `process.env.NODE_DISABLE_COLORS`.\n     *\n     * @example\n     * error.showSourceCode() //=> \"  4 | }\n     *                        //      5 | a {\n     *                        //    > 6 |   bad\n     *                        //        |   ^\n     *                        //      7 | }\n     *                        //      8 | b {\"\n     *\n     * @return {string} few lines of CSS source that caused the error\n     */\n    showSourceCode(color) {\n        if ( !this.source ) return '';\n\n        let css = this.source;\n        if ( typeof color === 'undefined' ) color = supportsColor.stdout;\n        if ( color ) css = terminalHighlight(css);\n\n        let lines = css.split(/\\r?\\n/);\n        let start = Math.max(this.line - 3, 0);\n        let end   = Math.min(this.line + 2, lines.length);\n\n        let maxWidth = String(end).length;\n\n        function mark(text) {\n            if ( color && chalk.red ) {\n                return chalk.red.bold(text);\n            } else {\n                return text;\n            }\n        }\n        function aside(text) {\n            if ( color && chalk.gray ) {\n                return chalk.gray(text);\n            } else {\n                return text;\n            }\n        }\n\n        return lines.slice(start, end).map( (line, index) => {\n            let number = start + 1 + index;\n            let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';\n            if ( number === this.line ) {\n                let spacing =\n                    aside(gutter.replace(/\\d/g, ' ')) +\n                    line.slice(0, this.column - 1).replace(/[^\\t]/g, ' ');\n                return mark('>') + aside(gutter) + line + '\\n ' +\n                       spacing + mark('^');\n            } else {\n                return ' ' + aside(gutter) + line;\n            }\n        }).join('\\n');\n    }\n\n    /**\n     * Returns error position, message and source code of the broken part.\n     *\n     * @example\n     * error.toString() //=> \"CssSyntaxError: app.css:1:1: Unclosed block\n     *                  //    > 1 | a {\n     *                  //        | ^\"\n     *\n     * @return {string} error position, message and source code\n     */\n    toString() {\n        let code = this.showSourceCode();\n        if ( code ) {\n            code = '\\n\\n' + code + '\\n';\n        }\n        return this.name + ': ' + this.message + code;\n    }\n\n    /**\n     * @memberof CssSyntaxError#\n     * @member {Input} input - Input object with PostCSS internal information\n     *                         about input file. If input has source map\n     *                         from previous tool, PostCSS will use origin\n     *                         (for example, Sass) source. You can use this\n     *                         object to get PostCSS input source.\n     *\n     * @example\n     * error.input.file //=> 'a.css'\n     * error.file       //=> 'a.sass'\n     */\n\n}\n\nexport default CssSyntaxError;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}