{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _declaration = require('./declaration');\nvar _declaration2 = _interopRequireDefault(_declaration);\nvar _warnOnce = require('./warn-once');\nvar _warnOnce2 = _interopRequireDefault(_warnOnce);\nvar _comment = require('./comment');\nvar _comment2 = _interopRequireDefault(_comment);\nvar _node = require('./node');\nvar _node2 = _interopRequireDefault(_node);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction cleanSource(nodes) {\n  return nodes.map(function (i) {\n    if (i.nodes) i.nodes = cleanSource(i.nodes);\n    delete i.source;\n    return i;\n  });\n}\n\n/**\n * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n * inherit some common methods to help work with their children.\n *\n * Note that all containers can store any content. If you write a rule inside\n * a rule, PostCSS will parse it.\n *\n * @extends Node\n * @abstract\n */\n\nvar Container = function (_Node) {\n  _inherits(Container, _Node);\n  function Container() {\n    _classCallCheck(this, Container);\n    return _possibleConstructorReturn(this, _Node.apply(this, arguments));\n  }\n  Container.prototype.push = function push(child) {\n    child.parent = this;\n    this.nodes.push(child);\n    return this;\n  };\n\n  /**\n   * Iterates through the container’s immediate children,\n   * calling `callback` for each child.\n   *\n   * Returning `false` in the callback will break iteration.\n   *\n   * This method only iterates through the container’s immediate children.\n   * If you need to recursively iterate through all the container’s descendant\n   * nodes, use {@link Container#walk}.\n   *\n   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n   * if you are mutating the array of child nodes during iteration.\n   * PostCSS will adjust the current index to match the mutations.\n   *\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * const root = postcss.parse('a { color: black; z-index: 1 }');\n   * const rule = root.first;\n   *\n   * for ( let decl of rule.nodes ) {\n   *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n   *     // Cycle will be infinite, because cloneBefore moves the current node\n   *     // to the next index\n   * }\n   *\n   * rule.each(decl => {\n   *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n   *     // Will be executed only for color and z-index\n   * });\n   */\n\n  Container.prototype.each = function each(callback) {\n    if (!this.lastEach) this.lastEach = 0;\n    if (!this.indexes) this.indexes = {};\n    this.lastEach += 1;\n    var id = this.lastEach;\n    this.indexes[id] = 0;\n    if (!this.nodes) return undefined;\n    var index = void 0,\n      result = void 0;\n    while (this.indexes[id] < this.nodes.length) {\n      index = this.indexes[id];\n      result = callback(this.nodes[index], index);\n      if (result === false) break;\n      this.indexes[id] += 1;\n    }\n    delete this.indexes[id];\n    return result;\n  };\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each node.\n   *\n   * Like container.each(), this method is safe to use\n   * if you are mutating arrays during iteration.\n   *\n   * If you only need to iterate through the container’s immediate children,\n   * use {@link Container#each}.\n   *\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walk(node => {\n   *   // Traverses all descendant nodes.\n   * });\n   */\n\n  Container.prototype.walk = function walk(callback) {\n    return this.each(function (child, i) {\n      var result = callback(child, i);\n      if (result !== false && child.walk) {\n        result = child.walk(callback);\n      }\n      return result;\n    });\n  };\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each declaration node.\n   *\n   * If you pass a filter, iteration will only happen over declarations\n   * with matching properties.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [prop]   - string or regular expression\n   *                                   to filter declarations by property name\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walkDecls(decl => {\n   *   checkPropertySupport(decl.prop);\n   * });\n   *\n   * root.walkDecls('border-radius', decl => {\n   *   decl.remove();\n   * });\n   *\n   * root.walkDecls(/^background/, decl => {\n   *   decl.value = takeFirstColorFromGradient(decl.value);\n   * });\n   */\n\n  Container.prototype.walkDecls = function walkDecls(prop, callback) {\n    if (!callback) {\n      callback = prop;\n      return this.walk(function (child, i) {\n        if (child.type === 'decl') {\n          return callback(child, i);\n        }\n      });\n    } else if (prop instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i);\n        }\n      });\n    } else {\n      return this.walk(function (child, i) {\n        if (child.type === 'decl' && child.prop === prop) {\n          return callback(child, i);\n        }\n      });\n    }\n  };\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each rule node.\n   *\n   * If you pass a filter, iteration will only happen over rules\n   * with matching selectors.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [selector] - string or regular expression\n   *                                     to filter rules by selector\n   * @param {childIterator} callback   - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * const selectors = [];\n   * root.walkRules(rule => {\n   *   selectors.push(rule.selector);\n   * });\n   * console.log(`Your CSS uses ${selectors.length} selectors`);\n   */\n\n  Container.prototype.walkRules = function walkRules(selector, callback) {\n    if (!callback) {\n      callback = selector;\n      return this.walk(function (child, i) {\n        if (child.type === 'rule') {\n          return callback(child, i);\n        }\n      });\n    } else if (selector instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i);\n        }\n      });\n    } else {\n      return this.walk(function (child, i) {\n        if (child.type === 'rule' && child.selector === selector) {\n          return callback(child, i);\n        }\n      });\n    }\n  };\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each at-rule node.\n   *\n   * If you pass a filter, iteration will only happen over at-rules\n   * that have matching names.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [name]   - string or regular expression\n   *                                   to filter at-rules by name\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walkAtRules(rule => {\n   *   if ( isOld(rule.name) ) rule.remove();\n   * });\n   *\n   * let first = false;\n   * root.walkAtRules('charset', rule => {\n   *   if ( !first ) {\n   *     first = true;\n   *   } else {\n   *     rule.remove();\n   *   }\n   * });\n   */\n\n  Container.prototype.walkAtRules = function walkAtRules(name, callback) {\n    if (!callback) {\n      callback = name;\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule') {\n          return callback(child, i);\n        }\n      });\n    } else if (name instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i);\n        }\n      });\n    } else {\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule' && child.name === name) {\n          return callback(child, i);\n        }\n      });\n    }\n  };\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each comment node.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walkComments(comment => {\n   *   comment.remove();\n   * });\n   */\n\n  Container.prototype.walkComments = function walkComments(callback) {\n    return this.walk(function (child, i) {\n      if (child.type === 'comment') {\n        return callback(child, i);\n      }\n    });\n  };\n\n  /**\n   * Inserts new nodes to the end of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children - new nodes\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n   * rule.append(decl1, decl2);\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n   * root.append({ selector: 'a' });                       // rule\n   * rule.append({ prop: 'color', value: 'black' });       // declaration\n   * rule.append({ text: 'Comment' })                      // comment\n   *\n   * root.append('a {}');\n   * root.first.append('color: black; z-index: 1');\n   */\n\n  Container.prototype.append = function append() {\n    for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {\n      children[_key] = arguments[_key];\n    }\n    for (var _iterator = children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n      var child = _ref;\n      var nodes = this.normalize(child, this.last);\n      for (var _iterator2 = nodes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n        var node = _ref2;\n        this.nodes.push(node);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Inserts new nodes to the start of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children - new nodes\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n   * rule.prepend(decl1, decl2);\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n   * root.append({ selector: 'a' });                       // rule\n   * rule.append({ prop: 'color', value: 'black' });       // declaration\n   * rule.append({ text: 'Comment' })                      // comment\n   *\n   * root.append('a {}');\n   * root.first.append('color: black; z-index: 1');\n   */\n\n  Container.prototype.prepend = function prepend() {\n    for (var _len2 = arguments.length, children = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      children[_key2] = arguments[_key2];\n    }\n    children = children.reverse();\n    for (var _iterator3 = children, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n      var child = _ref3;\n      var nodes = this.normalize(child, this.first, 'prepend').reverse();\n      for (var _iterator4 = nodes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n        var _ref4;\n        if (_isArray4) {\n          if (_i4 >= _iterator4.length) break;\n          _ref4 = _iterator4[_i4++];\n        } else {\n          _i4 = _iterator4.next();\n          if (_i4.done) break;\n          _ref4 = _i4.value;\n        }\n        var node = _ref4;\n        this.nodes.unshift(node);\n      }\n      for (var id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length;\n      }\n    }\n    return this;\n  };\n  Container.prototype.cleanRaws = function cleanRaws(keepBetween) {\n    _Node.prototype.cleanRaws.call(this, keepBetween);\n    if (this.nodes) {\n      for (var _iterator5 = this.nodes, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n        var _ref5;\n        if (_isArray5) {\n          if (_i5 >= _iterator5.length) break;\n          _ref5 = _iterator5[_i5++];\n        } else {\n          _i5 = _iterator5.next();\n          if (_i5.done) break;\n          _ref5 = _i5.value;\n        }\n        var node = _ref5;\n        node.cleanRaws(keepBetween);\n      }\n    }\n  };\n\n  /**\n   * Insert new node before old node within the container.\n   *\n   * @param {Node|number} exist             - child or child’s index.\n   * @param {Node|object|string|Node[]} add - new node\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }));\n   */\n\n  Container.prototype.insertBefore = function insertBefore(exist, add) {\n    exist = this.index(exist);\n    var type = exist === 0 ? 'prepend' : false;\n    var nodes = this.normalize(add, this.nodes[exist], type).reverse();\n    for (var _iterator6 = nodes, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n      var _ref6;\n      if (_isArray6) {\n        if (_i6 >= _iterator6.length) break;\n        _ref6 = _iterator6[_i6++];\n      } else {\n        _i6 = _iterator6.next();\n        if (_i6.done) break;\n        _ref6 = _i6.value;\n      }\n      var node = _ref6;\n      this.nodes.splice(exist, 0, node);\n    }\n    var index = void 0;\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n      if (exist <= index) {\n        this.indexes[id] = index + nodes.length;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Insert new node after old node within the container.\n   *\n   * @param {Node|number} exist             - child or child’s index\n   * @param {Node|object|string|Node[]} add - new node\n   *\n   * @return {Node} this node for methods chain\n   */\n\n  Container.prototype.insertAfter = function insertAfter(exist, add) {\n    exist = this.index(exist);\n    var nodes = this.normalize(add, this.nodes[exist]).reverse();\n    for (var _iterator7 = nodes, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {\n      var _ref7;\n      if (_isArray7) {\n        if (_i7 >= _iterator7.length) break;\n        _ref7 = _iterator7[_i7++];\n      } else {\n        _i7 = _iterator7.next();\n        if (_i7.done) break;\n        _ref7 = _i7.value;\n      }\n      var node = _ref7;\n      this.nodes.splice(exist + 1, 0, node);\n    }\n    var index = void 0;\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n      if (exist < index) {\n        this.indexes[id] = index + nodes.length;\n      }\n    }\n    return this;\n  };\n  Container.prototype.remove = function remove(child) {\n    if (typeof child !== 'undefined') {\n      (0, _warnOnce2.default)('Container#remove is deprecated. ' + 'Use Container#removeChild');\n      this.removeChild(child);\n    } else {\n      _Node.prototype.remove.call(this);\n    }\n    return this;\n  };\n\n  /**\n   * Removes node from the container and cleans the parent properties\n   * from the node and its children.\n   *\n   * @param {Node|number} child - child or child’s index\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * rule.nodes.length  //=> 5\n   * rule.removeChild(decl);\n   * rule.nodes.length  //=> 4\n   * decl.parent        //=> undefined\n   */\n\n  Container.prototype.removeChild = function removeChild(child) {\n    child = this.index(child);\n    this.nodes[child].parent = undefined;\n    this.nodes.splice(child, 1);\n    var index = void 0;\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n      if (index >= child) {\n        this.indexes[id] = index - 1;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Removes all children from the container\n   * and cleans their parent properties.\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * rule.removeAll();\n   * rule.nodes.length //=> 0\n   */\n\n  Container.prototype.removeAll = function removeAll() {\n    for (var _iterator8 = this.nodes, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {\n      var _ref8;\n      if (_isArray8) {\n        if (_i8 >= _iterator8.length) break;\n        _ref8 = _iterator8[_i8++];\n      } else {\n        _i8 = _iterator8.next();\n        if (_i8.done) break;\n        _ref8 = _i8.value;\n      }\n      var node = _ref8;\n      node.parent = undefined;\n    }\n    this.nodes = [];\n    return this;\n  };\n\n  /**\n   * Passes all declaration values within the container that match pattern\n   * through callback, replacing those values with the returned result\n   * of callback.\n   *\n   * This method is useful if you are using a custom unit or function\n   * and need to iterate through all values.\n   *\n   * @param {string|RegExp} pattern      - replace pattern\n   * @param {object} opts                - options to speed up the search\n   * @param {string|string[]} opts.props - an array of property names\n   * @param {string} opts.fast           - string that’s used\n   *                                       to narrow down values and speed up\n                                           the regexp search\n   * @param {function|string} callback   - string to replace pattern\n   *                                       or callback that returns a new\n   *                                       value.\n   *                                       The callback will receive\n   *                                       the same arguments as those\n   *                                       passed to a function parameter\n   *                                       of `String#replace`.\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n   *   return 15 * parseInt(string) + 'px';\n   * });\n   */\n\n  Container.prototype.replaceValues = function replaceValues(pattern, opts, callback) {\n    if (!callback) {\n      callback = opts;\n      opts = {};\n    }\n    this.walkDecls(function (decl) {\n      if (opts.props && opts.props.indexOf(decl.prop) === -1) return;\n      if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;\n      decl.value = decl.value.replace(pattern, callback);\n    });\n    return this;\n  };\n\n  /**\n   * Returns `true` if callback returns `true`\n   * for all of the container’s children.\n   *\n   * @param {childCondition} condition - iterator returns true or false.\n   *\n   * @return {boolean} is every child pass condition\n   *\n   * @example\n   * const noPrefixes = rule.every(i => i.prop[0] !== '-');\n   */\n\n  Container.prototype.every = function every(condition) {\n    return this.nodes.every(condition);\n  };\n\n  /**\n   * Returns `true` if callback returns `true` for (at least) one\n   * of the container’s children.\n   *\n   * @param {childCondition} condition - iterator returns true or false.\n   *\n   * @return {boolean} is some child pass condition\n   *\n   * @example\n   * const hasPrefix = rule.some(i => i.prop[0] === '-');\n   */\n\n  Container.prototype.some = function some(condition) {\n    return this.nodes.some(condition);\n  };\n\n  /**\n   * Returns a `child`’s index within the {@link Container#nodes} array.\n   *\n   * @param {Node} child - child of the current container.\n   *\n   * @return {number} child index\n   *\n   * @example\n   * rule.index( rule.nodes[2] ) //=> 2\n   */\n\n  Container.prototype.index = function index(child) {\n    if (typeof child === 'number') {\n      return child;\n    } else {\n      return this.nodes.indexOf(child);\n    }\n  };\n\n  /**\n   * The container’s first child.\n   *\n   * @type {Node}\n   *\n   * @example\n   * rule.first == rules.nodes[0];\n   */\n\n  Container.prototype.normalize = function normalize(nodes, sample) {\n    var _this2 = this;\n    if (typeof nodes === 'string') {\n      var parse = require('./parse');\n      nodes = cleanSource(parse(nodes).nodes);\n    } else if (!Array.isArray(nodes)) {\n      if (nodes.type === 'root') {\n        nodes = nodes.nodes;\n      } else if (nodes.type) {\n        nodes = [nodes];\n      } else if (nodes.prop) {\n        if (typeof nodes.value === 'undefined') {\n          throw new Error('Value field is missed in node creation');\n        } else if (typeof nodes.value !== 'string') {\n          nodes.value = String(nodes.value);\n        }\n        nodes = [new _declaration2.default(nodes)];\n      } else if (nodes.selector) {\n        var Rule = require('./rule');\n        nodes = [new Rule(nodes)];\n      } else if (nodes.name) {\n        var AtRule = require('./at-rule');\n        nodes = [new AtRule(nodes)];\n      } else if (nodes.text) {\n        nodes = [new _comment2.default(nodes)];\n      } else {\n        throw new Error('Unknown node type in node creation');\n      }\n    }\n    var processed = nodes.map(function (i) {\n      if (typeof i.raws === 'undefined') i = _this2.rebuild(i);\n      if (i.parent) i = i.clone();\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/[^\\s]/g, '');\n        }\n      }\n      i.parent = _this2;\n      return i;\n    });\n    return processed;\n  };\n  Container.prototype.rebuild = function rebuild(node, parent) {\n    var _this3 = this;\n    var fix = void 0;\n    if (node.type === 'root') {\n      var Root = require('./root');\n      fix = new Root();\n    } else if (node.type === 'atrule') {\n      var AtRule = require('./at-rule');\n      fix = new AtRule();\n    } else if (node.type === 'rule') {\n      var Rule = require('./rule');\n      fix = new Rule();\n    } else if (node.type === 'decl') {\n      fix = new _declaration2.default();\n    } else if (node.type === 'comment') {\n      fix = new _comment2.default();\n    }\n    for (var i in node) {\n      if (i === 'nodes') {\n        fix.nodes = node.nodes.map(function (j) {\n          return _this3.rebuild(j, fix);\n        });\n      } else if (i === 'parent' && parent) {\n        fix.parent = parent;\n      } else if (node.hasOwnProperty(i)) {\n        fix[i] = node[i];\n      }\n    }\n    return fix;\n  };\n  Container.prototype.eachInside = function eachInside(callback) {\n    (0, _warnOnce2.default)('Container#eachInside is deprecated. ' + 'Use Container#walk instead.');\n    return this.walk(callback);\n  };\n  Container.prototype.eachDecl = function eachDecl(prop, callback) {\n    (0, _warnOnce2.default)('Container#eachDecl is deprecated. ' + 'Use Container#walkDecls instead.');\n    return this.walkDecls(prop, callback);\n  };\n  Container.prototype.eachRule = function eachRule(selector, callback) {\n    (0, _warnOnce2.default)('Container#eachRule is deprecated. ' + 'Use Container#walkRules instead.');\n    return this.walkRules(selector, callback);\n  };\n  Container.prototype.eachAtRule = function eachAtRule(name, callback) {\n    (0, _warnOnce2.default)('Container#eachAtRule is deprecated. ' + 'Use Container#walkAtRules instead.');\n    return this.walkAtRules(name, callback);\n  };\n  Container.prototype.eachComment = function eachComment(callback) {\n    (0, _warnOnce2.default)('Container#eachComment is deprecated. ' + 'Use Container#walkComments instead.');\n    return this.walkComments(callback);\n  };\n  _createClass(Container, [{\n    key: 'first',\n    get: function get() {\n      if (!this.nodes) return undefined;\n      return this.nodes[0];\n    }\n\n    /**\n     * The container’s last child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.last == rule.nodes[rule.nodes.length - 1];\n     */\n  }, {\n    key: 'last',\n    get: function get() {\n      if (!this.nodes) return undefined;\n      return this.nodes[this.nodes.length - 1];\n    }\n  }, {\n    key: 'semicolon',\n    get: function get() {\n      (0, _warnOnce2.default)('Node#semicolon is deprecated. Use Node#raws.semicolon');\n      return this.raws.semicolon;\n    },\n    set: function set(val) {\n      (0, _warnOnce2.default)('Node#semicolon is deprecated. Use Node#raws.semicolon');\n      this.raws.semicolon = val;\n    }\n  }, {\n    key: 'after',\n    get: function get() {\n      (0, _warnOnce2.default)('Node#after is deprecated. Use Node#raws.after');\n      return this.raws.after;\n    },\n    set: function set(val) {\n      (0, _warnOnce2.default)('Node#after is deprecated. Use Node#raws.after');\n      this.raws.after = val;\n    }\n\n    /**\n     * @memberof Container#\n     * @member {Node[]} nodes - an array containing the container’s children\n     *\n     * @example\n     * const root = postcss.parse('a { color: black }');\n     * root.nodes.length           //=> 1\n     * root.nodes[0].selector      //=> 'a'\n     * root.nodes[0].nodes[0].prop //=> 'color'\n     */\n  }]);\n\n  return Container;\n}(_node2.default);\nexports.default = Container;\n\n/**\n * @callback childCondition\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @param {Node[]} nodes - all container children\n * @return {boolean}\n */\n\n/**\n * @callback childIterator\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @return {false|undefined} returning `false` will break iteration\n */\n\nmodule.exports = exports['default'];","map":{"version":3,"names":["_declaration","require","_warnOnce","_comment","_node","cleanSource","nodes","map","i","source","Container","push","child","parent","each","callback","lastEach","indexes","id","undefined","index","result","length","walk","walkDecls","prop","type","RegExp","test","walkRules","selector","walkAtRules","name","walkComments","append","_len","arguments","children","Array","_key","_iterator","_isArray","isArray","_i","Symbol","iterator","_ref","next","done","value","normalize","last","_iterator2","_isArray2","_i2","_ref2","node","prepend","_len2","_key2","reverse","_iterator3","_isArray3","_i3","_ref3","first","_iterator4","_isArray4","_i4","_ref4","unshift","cleanRaws","keepBetween","_Node","prototype","call","_iterator5","_isArray5","_i5","_ref5","insertBefore","exist","add","_iterator6","_isArray6","_i6","_ref6","splice","insertAfter","_iterator7","_isArray7","_i7","_ref7","remove","_warnOnce2","default","removeChild","removeAll","_iterator8","_isArray8","_i8","_ref8","replaceValues","pattern","opts","decl","props","indexOf","fast","replace","every","condition","some","sample","_this2","parse","Error","String","_declaration2","Rule","AtRule","text","_comment2","processed","raws","rebuild","clone","before","_this3","fix","Root","j","hasOwnProperty","eachInside","eachDecl","eachRule","eachAtRule","eachComment","semicolon","val","after"],"sources":["C:\\Users\\Francisco\\Documents\\GitHub\\examenApi\\EXAMEN-API-NOTICIAS\\node_modules\\postcss-scss\\node_modules\\postcss\\lib\\container.es6"],"sourcesContent":["import Declaration from './declaration';\nimport warnOnce    from './warn-once';\nimport Comment     from './comment';\nimport Node        from './node';\n\nfunction cleanSource(nodes) {\n    return nodes.map( i => {\n        if ( i.nodes ) i.nodes = cleanSource(i.nodes);\n        delete i.source;\n        return i;\n    });\n}\n\n/**\n * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n * inherit some common methods to help work with their children.\n *\n * Note that all containers can store any content. If you write a rule inside\n * a rule, PostCSS will parse it.\n *\n * @extends Node\n * @abstract\n */\nclass Container extends Node {\n\n    push(child) {\n        child.parent = this;\n        this.nodes.push(child);\n        return this;\n    }\n\n    /**\n     * Iterates through the container’s immediate children,\n     * calling `callback` for each child.\n     *\n     * Returning `false` in the callback will break iteration.\n     *\n     * This method only iterates through the container’s immediate children.\n     * If you need to recursively iterate through all the container’s descendant\n     * nodes, use {@link Container#walk}.\n     *\n     * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n     * if you are mutating the array of child nodes during iteration.\n     * PostCSS will adjust the current index to match the mutations.\n     *\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * const root = postcss.parse('a { color: black; z-index: 1 }');\n     * const rule = root.first;\n     *\n     * for ( let decl of rule.nodes ) {\n     *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n     *     // Cycle will be infinite, because cloneBefore moves the current node\n     *     // to the next index\n     * }\n     *\n     * rule.each(decl => {\n     *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n     *     // Will be executed only for color and z-index\n     * });\n     */\n    each(callback) {\n        if ( !this.lastEach ) this.lastEach = 0;\n        if ( !this.indexes ) this.indexes = { };\n\n        this.lastEach += 1;\n        let id = this.lastEach;\n        this.indexes[id] = 0;\n\n        if ( !this.nodes ) return undefined;\n\n        let index, result;\n        while ( this.indexes[id] < this.nodes.length ) {\n            index  = this.indexes[id];\n            result = callback(this.nodes[index], index);\n            if ( result === false ) break;\n\n            this.indexes[id] += 1;\n        }\n\n        delete this.indexes[id];\n\n        return result;\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each node.\n     *\n     * Like container.each(), this method is safe to use\n     * if you are mutating arrays during iteration.\n     *\n     * If you only need to iterate through the container’s immediate children,\n     * use {@link Container#each}.\n     *\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walk(node => {\n     *   // Traverses all descendant nodes.\n     * });\n     */\n    walk(callback) {\n        return this.each( (child, i) => {\n            let result = callback(child, i);\n            if ( result !== false && child.walk ) {\n                result = child.walk(callback);\n            }\n            return result;\n        });\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each declaration node.\n     *\n     * If you pass a filter, iteration will only happen over declarations\n     * with matching properties.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {string|RegExp} [prop]   - string or regular expression\n     *                                   to filter declarations by property name\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walkDecls(decl => {\n     *   checkPropertySupport(decl.prop);\n     * });\n     *\n     * root.walkDecls('border-radius', decl => {\n     *   decl.remove();\n     * });\n     *\n     * root.walkDecls(/^background/, decl => {\n     *   decl.value = takeFirstColorFromGradient(decl.value);\n     * });\n     */\n    walkDecls(prop, callback) {\n        if ( !callback ) {\n            callback = prop;\n            return this.walk( (child, i) => {\n                if ( child.type === 'decl' ) {\n                    return callback(child, i);\n                }\n            });\n        } else if ( prop instanceof RegExp ) {\n            return this.walk( (child, i) => {\n                if ( child.type === 'decl' && prop.test(child.prop) ) {\n                    return callback(child, i);\n                }\n            });\n        } else {\n            return this.walk( (child, i) => {\n                if ( child.type === 'decl' && child.prop === prop ) {\n                    return callback(child, i);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each rule node.\n     *\n     * If you pass a filter, iteration will only happen over rules\n     * with matching selectors.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {string|RegExp} [selector] - string or regular expression\n     *                                     to filter rules by selector\n     * @param {childIterator} callback   - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * const selectors = [];\n     * root.walkRules(rule => {\n     *   selectors.push(rule.selector);\n     * });\n     * console.log(`Your CSS uses ${selectors.length} selectors`);\n     */\n    walkRules(selector, callback) {\n        if ( !callback ) {\n            callback = selector;\n\n            return this.walk( (child, i) => {\n                if ( child.type === 'rule' ) {\n                    return callback(child, i);\n                }\n            });\n        } else if ( selector instanceof RegExp ) {\n            return this.walk( (child, i) => {\n                if ( child.type === 'rule' && selector.test(child.selector) ) {\n                    return callback(child, i);\n                }\n            });\n        } else {\n            return this.walk( (child, i) => {\n                if ( child.type === 'rule' && child.selector === selector ) {\n                    return callback(child, i);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each at-rule node.\n     *\n     * If you pass a filter, iteration will only happen over at-rules\n     * that have matching names.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {string|RegExp} [name]   - string or regular expression\n     *                                   to filter at-rules by name\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walkAtRules(rule => {\n     *   if ( isOld(rule.name) ) rule.remove();\n     * });\n     *\n     * let first = false;\n     * root.walkAtRules('charset', rule => {\n     *   if ( !first ) {\n     *     first = true;\n     *   } else {\n     *     rule.remove();\n     *   }\n     * });\n     */\n    walkAtRules(name, callback) {\n        if ( !callback ) {\n            callback = name;\n            return this.walk( (child, i) => {\n                if ( child.type === 'atrule' ) {\n                    return callback(child, i);\n                }\n            });\n        } else if ( name instanceof RegExp ) {\n            return this.walk( (child, i) => {\n                if ( child.type === 'atrule' && name.test(child.name) ) {\n                    return callback(child, i);\n                }\n            });\n        } else {\n            return this.walk( (child, i) => {\n                if ( child.type === 'atrule' && child.name === name ) {\n                    return callback(child, i);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each comment node.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walkComments(comment => {\n     *   comment.remove();\n     * });\n     */\n    walkComments(callback) {\n        return this.walk( (child, i) => {\n            if ( child.type === 'comment' ) {\n                return callback(child, i);\n            }\n        });\n    }\n\n    /**\n     * Inserts new nodes to the end of the container.\n     *\n     * @param {...(Node|object|string|Node[])} children - new nodes\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n     * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n     * rule.append(decl1, decl2);\n     *\n     * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n     * root.append({ selector: 'a' });                       // rule\n     * rule.append({ prop: 'color', value: 'black' });       // declaration\n     * rule.append({ text: 'Comment' })                      // comment\n     *\n     * root.append('a {}');\n     * root.first.append('color: black; z-index: 1');\n     */\n    append(...children) {\n        for ( let child of children ) {\n            let nodes = this.normalize(child, this.last);\n            for ( let node of nodes ) this.nodes.push(node);\n        }\n        return this;\n    }\n\n    /**\n     * Inserts new nodes to the start of the container.\n     *\n     * @param {...(Node|object|string|Node[])} children - new nodes\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n     * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n     * rule.prepend(decl1, decl2);\n     *\n     * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n     * root.append({ selector: 'a' });                       // rule\n     * rule.append({ prop: 'color', value: 'black' });       // declaration\n     * rule.append({ text: 'Comment' })                      // comment\n     *\n     * root.append('a {}');\n     * root.first.append('color: black; z-index: 1');\n     */\n    prepend(...children) {\n        children = children.reverse();\n        for ( let child of children ) {\n            let nodes = this.normalize(child, this.first, 'prepend').reverse();\n            for ( let node of nodes ) this.nodes.unshift(node);\n            for ( let id in this.indexes ) {\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        return this;\n    }\n\n    cleanRaws(keepBetween) {\n        super.cleanRaws(keepBetween);\n        if ( this.nodes ) {\n            for ( let node of this.nodes ) node.cleanRaws(keepBetween);\n        }\n    }\n\n    /**\n     * Insert new node before old node within the container.\n     *\n     * @param {Node|number} exist             - child or child’s index.\n     * @param {Node|object|string|Node[]} add - new node\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }));\n     */\n    insertBefore(exist, add) {\n        exist = this.index(exist);\n\n        let type  = exist === 0 ? 'prepend' : false;\n        let nodes = this.normalize(add, this.nodes[exist], type).reverse();\n        for ( let node of nodes ) this.nodes.splice(exist, 0, node);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( exist <= index ) {\n                this.indexes[id] = index + nodes.length;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Insert new node after old node within the container.\n     *\n     * @param {Node|number} exist             - child or child’s index\n     * @param {Node|object|string|Node[]} add - new node\n     *\n     * @return {Node} this node for methods chain\n     */\n    insertAfter(exist, add) {\n        exist = this.index(exist);\n\n        let nodes = this.normalize(add, this.nodes[exist]).reverse();\n        for ( let node of nodes ) this.nodes.splice(exist + 1, 0, node);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( exist < index ) {\n                this.indexes[id] = index + nodes.length;\n            }\n        }\n\n        return this;\n    }\n\n    remove(child) {\n        if ( typeof child !== 'undefined' ) {\n            warnOnce('Container#remove is deprecated. ' +\n                     'Use Container#removeChild');\n            this.removeChild(child);\n        } else {\n            super.remove();\n        }\n        return this;\n    }\n\n    /**\n     * Removes node from the container and cleans the parent properties\n     * from the node and its children.\n     *\n     * @param {Node|number} child - child or child’s index\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * rule.nodes.length  //=> 5\n     * rule.removeChild(decl);\n     * rule.nodes.length  //=> 4\n     * decl.parent        //=> undefined\n     */\n    removeChild(child) {\n        child = this.index(child);\n        this.nodes[child].parent = undefined;\n        this.nodes.splice(child, 1);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( index >= child ) {\n                this.indexes[id] = index - 1;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes all children from the container\n     * and cleans their parent properties.\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * rule.removeAll();\n     * rule.nodes.length //=> 0\n     */\n    removeAll() {\n        for ( let node of this.nodes ) node.parent = undefined;\n        this.nodes = [];\n        return this;\n    }\n\n    /**\n     * Passes all declaration values within the container that match pattern\n     * through callback, replacing those values with the returned result\n     * of callback.\n     *\n     * This method is useful if you are using a custom unit or function\n     * and need to iterate through all values.\n     *\n     * @param {string|RegExp} pattern      - replace pattern\n     * @param {object} opts                - options to speed up the search\n     * @param {string|string[]} opts.props - an array of property names\n     * @param {string} opts.fast           - string that’s used\n     *                                       to narrow down values and speed up\n                                             the regexp search\n     * @param {function|string} callback   - string to replace pattern\n     *                                       or callback that returns a new\n     *                                       value.\n     *                                       The callback will receive\n     *                                       the same arguments as those\n     *                                       passed to a function parameter\n     *                                       of `String#replace`.\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n     *   return 15 * parseInt(string) + 'px';\n     * });\n     */\n    replaceValues(pattern, opts, callback) {\n        if ( !callback ) {\n            callback = opts;\n            opts = { };\n        }\n\n        this.walkDecls( decl => {\n            if ( opts.props && opts.props.indexOf(decl.prop) === -1 ) return;\n            if ( opts.fast  && decl.value.indexOf(opts.fast) === -1 ) return;\n\n            decl.value = decl.value.replace(pattern, callback);\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns `true` if callback returns `true`\n     * for all of the container’s children.\n     *\n     * @param {childCondition} condition - iterator returns true or false.\n     *\n     * @return {boolean} is every child pass condition\n     *\n     * @example\n     * const noPrefixes = rule.every(i => i.prop[0] !== '-');\n     */\n    every(condition) {\n        return this.nodes.every(condition);\n    }\n\n    /**\n     * Returns `true` if callback returns `true` for (at least) one\n     * of the container’s children.\n     *\n     * @param {childCondition} condition - iterator returns true or false.\n     *\n     * @return {boolean} is some child pass condition\n     *\n     * @example\n     * const hasPrefix = rule.some(i => i.prop[0] === '-');\n     */\n    some(condition) {\n        return this.nodes.some(condition);\n    }\n\n    /**\n     * Returns a `child`’s index within the {@link Container#nodes} array.\n     *\n     * @param {Node} child - child of the current container.\n     *\n     * @return {number} child index\n     *\n     * @example\n     * rule.index( rule.nodes[2] ) //=> 2\n     */\n    index(child) {\n        if ( typeof child === 'number' ) {\n            return child;\n        } else {\n            return this.nodes.indexOf(child);\n        }\n    }\n\n    /**\n     * The container’s first child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.first == rules.nodes[0];\n     */\n    get first() {\n        if ( !this.nodes ) return undefined;\n        return this.nodes[0];\n    }\n\n    /**\n     * The container’s last child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.last == rule.nodes[rule.nodes.length - 1];\n     */\n    get last() {\n        if ( !this.nodes ) return undefined;\n        return this.nodes[this.nodes.length - 1];\n    }\n\n    normalize(nodes, sample) {\n        if ( typeof nodes === 'string' ) {\n            let parse = require('./parse');\n            nodes = cleanSource(parse(nodes).nodes);\n        } else if ( !Array.isArray(nodes) ) {\n            if ( nodes.type === 'root' ) {\n                nodes = nodes.nodes;\n            } else if ( nodes.type ) {\n                nodes = [nodes];\n            } else if ( nodes.prop ) {\n                if ( typeof nodes.value === 'undefined' ) {\n                    throw new Error('Value field is missed in node creation');\n                } else if ( typeof nodes.value !== 'string' ) {\n                    nodes.value = String(nodes.value);\n                }\n                nodes = [new Declaration(nodes)];\n            } else if ( nodes.selector ) {\n                let Rule = require('./rule');\n                nodes = [new Rule(nodes)];\n            } else if ( nodes.name ) {\n                let AtRule = require('./at-rule');\n                nodes = [new AtRule(nodes)];\n            } else if ( nodes.text ) {\n                nodes = [new Comment(nodes)];\n            } else {\n                throw new Error('Unknown node type in node creation');\n            }\n        }\n\n        let processed = nodes.map( i => {\n            if ( typeof i.raws === 'undefined' ) i = this.rebuild(i);\n\n            if ( i.parent ) i = i.clone();\n            if ( typeof i.raws.before === 'undefined' ) {\n                if ( sample && typeof sample.raws.before !== 'undefined' ) {\n                    i.raws.before = sample.raws.before.replace(/[^\\s]/g, '');\n                }\n            }\n            i.parent = this;\n            return i;\n        });\n\n        return processed;\n    }\n\n    rebuild(node, parent) {\n        let fix;\n        if ( node.type === 'root' ) {\n            let Root = require('./root');\n            fix = new Root();\n        } else if ( node.type === 'atrule' ) {\n            let AtRule = require('./at-rule');\n            fix = new AtRule();\n        } else if ( node.type === 'rule' ) {\n            let Rule = require('./rule');\n            fix = new Rule();\n        } else if ( node.type === 'decl' ) {\n            fix = new Declaration();\n        } else if ( node.type === 'comment' ) {\n            fix = new Comment();\n        }\n\n        for ( let i in node ) {\n            if ( i === 'nodes' ) {\n                fix.nodes = node.nodes.map( j => this.rebuild(j, fix) );\n            } else if ( i === 'parent' && parent ) {\n                fix.parent = parent;\n            } else if ( node.hasOwnProperty(i) ) {\n                fix[i] = node[i];\n            }\n        }\n\n        return fix;\n    }\n\n    eachInside(callback) {\n        warnOnce('Container#eachInside is deprecated. ' +\n                 'Use Container#walk instead.');\n        return this.walk(callback);\n    }\n\n    eachDecl(prop, callback) {\n        warnOnce('Container#eachDecl is deprecated. ' +\n                 'Use Container#walkDecls instead.');\n        return this.walkDecls(prop, callback);\n    }\n\n    eachRule(selector, callback) {\n        warnOnce('Container#eachRule is deprecated. ' +\n                 'Use Container#walkRules instead.');\n        return this.walkRules(selector, callback);\n    }\n\n    eachAtRule(name, callback) {\n        warnOnce('Container#eachAtRule is deprecated. ' +\n                 'Use Container#walkAtRules instead.');\n        return this.walkAtRules(name, callback);\n    }\n\n    eachComment(callback) {\n        warnOnce('Container#eachComment is deprecated. ' +\n                 'Use Container#walkComments instead.');\n        return this.walkComments(callback);\n    }\n\n    get semicolon() {\n        warnOnce('Node#semicolon is deprecated. Use Node#raws.semicolon');\n        return this.raws.semicolon;\n    }\n\n    set semicolon(val) {\n        warnOnce('Node#semicolon is deprecated. Use Node#raws.semicolon');\n        this.raws.semicolon = val;\n    }\n\n    get after() {\n        warnOnce('Node#after is deprecated. Use Node#raws.after');\n        return this.raws.after;\n    }\n\n    set after(val) {\n        warnOnce('Node#after is deprecated. Use Node#raws.after');\n        this.raws.after = val;\n    }\n\n    /**\n     * @memberof Container#\n     * @member {Node[]} nodes - an array containing the container’s children\n     *\n     * @example\n     * const root = postcss.parse('a { color: black }');\n     * root.nodes.length           //=> 1\n     * root.nodes[0].selector      //=> 'a'\n     * root.nodes[0].nodes[0].prop //=> 'color'\n     */\n\n}\n\nexport default Container;\n\n\n/**\n * @callback childCondition\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @param {Node[]} nodes - all container children\n * @return {boolean}\n */\n\n/**\n * @callback childIterator\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @return {false|undefined} returning `false` will break iteration\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}