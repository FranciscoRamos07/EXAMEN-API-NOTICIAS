{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _comment = require('postcss/lib/comment');\nvar _comment2 = _interopRequireDefault(_comment);\nvar _parser = require('postcss/lib/parser');\nvar _parser2 = _interopRequireDefault(_parser);\nvar _nestedDeclaration = require('./nested-declaration');\nvar _nestedDeclaration2 = _interopRequireDefault(_nestedDeclaration);\nvar _scssTokenize = require('./scss-tokenize');\nvar _scssTokenize2 = _interopRequireDefault(_scssTokenize);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar ScssParser = function (_Parser) {\n  _inherits(ScssParser, _Parser);\n  function ScssParser() {\n    _classCallCheck(this, ScssParser);\n    return _possibleConstructorReturn(this, _Parser.apply(this, arguments));\n  }\n  ScssParser.prototype.tokenize = function tokenize() {\n    this.tokens = (0, _scssTokenize2.default)(this.input);\n  };\n  ScssParser.prototype.rule = function rule(tokens) {\n    var withColon = false;\n    var brackets = 0;\n    var value = '';\n    for (var _iterator = tokens, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n      var _i2 = _ref;\n      if (withColon) {\n        if (_i2[0] !== 'comment' && _i2[0] !== '{') {\n          value += _i2[1];\n        }\n      } else if (_i2[0] === 'space' && _i2[1].indexOf('\\n') !== -1) {\n        break;\n      } else if (_i2[0] === '(') {\n        brackets += 1;\n      } else if (_i2[0] === ')') {\n        brackets -= 1;\n      } else if (brackets === 0 && _i2[0] === ':') {\n        withColon = true;\n      }\n    }\n    if (!withColon || value.trim() === '' || /^[a-zA-Z-:#]/.test(value)) {\n      _Parser.prototype.rule.call(this, tokens);\n    } else {\n      tokens.pop();\n      var node = new _nestedDeclaration2.default();\n      this.init(node);\n      var last = tokens[tokens.length - 1];\n      if (last[4]) {\n        node.source.end = {\n          line: last[4],\n          column: last[5]\n        };\n      } else {\n        node.source.end = {\n          line: last[2],\n          column: last[3]\n        };\n      }\n      while (tokens[0][0] !== 'word') {\n        node.raws.before += tokens.shift()[1];\n      }\n      node.source.start = {\n        line: tokens[0][2],\n        column: tokens[0][3]\n      };\n      node.prop = '';\n      while (tokens.length) {\n        var type = tokens[0][0];\n        if (type === ':' || type === 'space' || type === 'comment') {\n          break;\n        }\n        node.prop += tokens.shift()[1];\n      }\n      node.raws.between = '';\n      var token = void 0;\n      while (tokens.length) {\n        token = tokens.shift();\n        if (token[0] === ':') {\n          node.raws.between += token[1];\n          break;\n        } else {\n          node.raws.between += token[1];\n        }\n      }\n      if (node.prop[0] === '_' || node.prop[0] === '*') {\n        node.raws.before += node.prop[0];\n        node.prop = node.prop.slice(1);\n      }\n      node.raws.between += this.spacesFromStart(tokens);\n      this.precheckMissedSemicolon(tokens);\n      for (var i = tokens.length - 1; i > 0; i--) {\n        token = tokens[i];\n        if (token[1] === '!important') {\n          node.important = true;\n          var string = this.stringFrom(tokens, i);\n          string = this.spacesFromEnd(tokens) + string;\n          if (string !== ' !important') {\n            node.raws.important = string;\n          }\n          break;\n        } else if (token[1] === 'important') {\n          var cache = tokens.slice(0);\n          var str = '';\n          for (var j = i; j > 0; j--) {\n            var _type = cache[j][0];\n            if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n              break;\n            }\n            str = cache.pop()[1] + str;\n          }\n          if (str.trim().indexOf('!') === 0) {\n            node.important = true;\n            node.raws.important = str;\n            tokens = cache;\n          }\n        }\n        if (token[0] !== 'space' && token[0] !== 'comment') {\n          break;\n        }\n      }\n      this.raw(node, 'value', tokens);\n      if (node.value.indexOf(':') !== -1) {\n        this.checkMissedSemicolon(tokens);\n      }\n      this.current = node;\n    }\n  };\n  ScssParser.prototype.comment = function comment(token) {\n    if (token[6] === 'inline') {\n      var node = new _comment2.default();\n      this.init(node, token[2], token[3]);\n      node.raws.inline = true;\n      node.source.end = {\n        line: token[4],\n        column: token[5]\n      };\n      var text = token[1].slice(2);\n      if (/^\\s*$/.test(text)) {\n        node.text = '';\n        node.raws.left = text;\n        node.raws.right = '';\n      } else {\n        var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n        node.text = match[2];\n        node.raws.left = match[1];\n        node.raws.right = match[3];\n      }\n    } else {\n      _Parser.prototype.comment.call(this, token);\n    }\n  };\n  return ScssParser;\n}(_parser2.default);\nexports.default = ScssParser;\nmodule.exports = exports['default'];","map":{"version":3,"names":["_comment","require","_parser","_nestedDeclaration","_scssTokenize","ScssParser","tokenize","tokens","_scssTokenize2","default","input","rule","withColon","brackets","value","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref","length","next","done","_i2","indexOf","trim","test","_Parser","prototype","call","pop","node","_nestedDeclaration2","init","last","source","end","line","column","raws","before","shift","start","prop","type","between","token","slice","spacesFromStart","precheckMissedSemicolon","i","important","string","stringFrom","spacesFromEnd","cache","str","j","_type","raw","checkMissedSemicolon","current","comment","_comment2","inline","text","left","right","match"],"sources":["\\source\\scss-parser.es6"],"sourcesContent":["import Comment from 'postcss/lib/comment';\nimport Parser  from 'postcss/lib/parser';\n\nimport NestedDeclaration from './nested-declaration';\nimport scssTokenizer     from './scss-tokenize';\n\nexport default class ScssParser extends Parser {\n\n    tokenize() {\n        this.tokens = scssTokenizer(this.input);\n    }\n\n    rule(tokens) {\n        let withColon = false;\n        let brackets  = 0;\n        let value     = '';\n        for ( let i of tokens ) {\n            if ( withColon ) {\n                if ( i[0] !== 'comment' && i[0] !== '{' ) {\n                    value += i[1];\n                }\n            } else if ( i[0] === 'space' && i[1].indexOf('\\n') !== -1 ) {\n                break;\n            } else if ( i[0] === '(' ) {\n                brackets += 1;\n            } else if ( i[0] === ')' ) {\n                brackets -= 1;\n            } else if ( brackets === 0 && i[0] === ':' ) {\n                withColon = true;\n            }\n        }\n\n        if ( !withColon || value.trim() === '' || /^[a-zA-Z-:#]/.test(value) ) {\n            super.rule(tokens);\n        } else {\n\n            tokens.pop();\n            let node = new NestedDeclaration();\n            this.init(node);\n\n            let last = tokens[tokens.length - 1];\n            if (last[4]) {\n                node.source.end = { line: last[4], column: last[5] };\n            } else {\n                node.source.end = { line: last[2], column: last[3] };\n            }\n\n            while (tokens[0][0] !== 'word') {\n                node.raws.before += tokens.shift()[1];\n            }\n            node.source.start = { line: tokens[0][2], column: tokens[0][3] };\n\n            node.prop = '';\n            while (tokens.length) {\n                let type = tokens[0][0];\n                if (type === ':' || type === 'space' || type === 'comment') {\n                    break;\n                }\n                node.prop += tokens.shift()[1];\n            }\n\n            node.raws.between = '';\n\n            let token;\n            while (tokens.length) {\n                token = tokens.shift();\n\n                if (token[0] === ':') {\n                    node.raws.between += token[1];\n                    break;\n                } else {\n                    node.raws.between += token[1];\n                }\n            }\n\n            if (node.prop[0] === '_' || node.prop[0] === '*') {\n                node.raws.before += node.prop[0];\n                node.prop = node.prop.slice(1);\n            }\n            node.raws.between += this.spacesFromStart(tokens);\n            this.precheckMissedSemicolon(tokens);\n\n            for (let i = tokens.length - 1; i > 0; i--) {\n                token = tokens[i];\n                if (token[1] === '!important') {\n                    node.important = true;\n                    let string = this.stringFrom(tokens, i);\n                    string = this.spacesFromEnd(tokens) + string;\n                    if (string !== ' !important') {\n                        node.raws.important = string;\n                    }\n                    break;\n\n                } else if (token[1] === 'important') {\n                    let cache = tokens.slice(0);\n                    let str   = '';\n                    for (let j = i; j > 0; j--) {\n                        let type = cache[j][0];\n                        if (str.trim().indexOf('!') === 0 &&\n                            type !== 'space'\n                        ) {\n                            break;\n                        }\n                        str = cache.pop()[1] + str;\n                    }\n                    if (str.trim().indexOf('!') === 0) {\n                        node.important = true;\n                        node.raws.important = str;\n                        tokens = cache;\n                    }\n                }\n\n                if (token[0] !== 'space' && token[0] !== 'comment') {\n                    break;\n                }\n            }\n\n            this.raw(node, 'value', tokens);\n\n            if (node.value.indexOf(':') !== -1) {\n                this.checkMissedSemicolon(tokens);\n            }\n\n            this.current = node;\n        }\n    }\n\n    comment(token) {\n        if (token[6] === 'inline') {\n            let node = new Comment();\n            this.init(node, token[2], token[3]);\n            node.raws.inline = true;\n            node.source.end  = { line: token[4], column: token[5] };\n\n            let text = token[1].slice(2);\n            if (/^\\s*$/.test(text)) {\n                node.text       = '';\n                node.raws.left  = text;\n                node.raws.right = '';\n            } else {\n                let match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n                node.text       = match[2];\n                node.raws.left  = match[1];\n                node.raws.right = match[3];\n            }\n        } else {\n            super.comment(token);\n        }\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}