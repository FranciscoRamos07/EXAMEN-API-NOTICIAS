{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar _mapGenerator = require('./map-generator');\nvar _mapGenerator2 = _interopRequireDefault(_mapGenerator);\nvar _stringify2 = require('./stringify');\nvar _stringify3 = _interopRequireDefault(_stringify2);\nvar _warnOnce = require('./warn-once');\nvar _warnOnce2 = _interopRequireDefault(_warnOnce);\nvar _result = require('./result');\nvar _result2 = _interopRequireDefault(_result);\nvar _parse = require('./parse');\nvar _parse2 = _interopRequireDefault(_parse);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction isPromise(obj) {\n  return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.then === 'function';\n}\n\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([cssnext]).process(css);\n */\n\nvar LazyResult = function () {\n  function LazyResult(processor, css, opts) {\n    _classCallCheck(this, LazyResult);\n    this.stringified = false;\n    this.processed = false;\n    var root = void 0;\n    if ((typeof css === 'undefined' ? 'undefined' : _typeof(css)) === 'object' && css.type === 'root') {\n      root = css;\n    } else if (css instanceof LazyResult || css instanceof _result2.default) {\n      root = css.root;\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {};\n        if (!opts.map.inline) opts.map.inline = false;\n        opts.map.prev = css.map;\n      }\n    } else {\n      var parser = _parse2.default;\n      if (opts.syntax) parser = opts.syntax.parse;\n      if (opts.parser) parser = opts.parser;\n      if (parser.parse) parser = parser.parse;\n      try {\n        root = parser(css, opts);\n      } catch (error) {\n        this.error = error;\n      }\n    }\n    this.result = new _result2.default(processor, root, opts);\n  }\n\n  /**\n   * Returns a {@link Processor} instance, which will be used\n   * for CSS transformations.\n   * @type {Processor}\n   */\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and calls {@link Result#warnings()}.\n   *\n   * @return {Warning[]} warnings from plugins\n   */\n  LazyResult.prototype.warnings = function warnings() {\n    return this.sync().warnings();\n  };\n\n  /**\n   * Alias for the {@link LazyResult#css} property.\n   *\n   * @example\n   * lazy + '' === lazy.css;\n   *\n   * @return {string} output CSS\n   */\n\n  LazyResult.prototype.toString = function toString() {\n    return this.css;\n  };\n\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls `onFulfilled` with a Result instance. If a plugin throws\n   * an error, the `onRejected` callback will be executed.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFulfilled} onFulfilled - callback will be executed\n   *                                    when all plugins will finish work\n   * @param {onRejected}  onRejected  - callback will be executed on any error\n   *\n   * @return {Promise} Promise API to make queue\n   *\n   * @example\n   * postcss([cssnext]).process(css).then(result => {\n   *   console.log(result.css);\n   * });\n   */\n\n  LazyResult.prototype.then = function then(onFulfilled, onRejected) {\n    return this.async().then(onFulfilled, onRejected);\n  };\n\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onRejected for each error thrown in any plugin.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onRejected} onRejected - callback will be executed on any error\n   *\n   * @return {Promise} Promise API to make queue\n   *\n   * @example\n   * postcss([cssnext]).process(css).then(result => {\n   *   console.log(result.css);\n   * }).catch(error => {\n   *   console.error(error);\n   * });\n   */\n\n  LazyResult.prototype.catch = function _catch(onRejected) {\n    return this.async().catch(onRejected);\n  };\n  LazyResult.prototype.handleError = function handleError(error, plugin) {\n    try {\n      this.error = error;\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin;\n        error.setMessage();\n      } else if (plugin.postcssVersion) {\n        var pluginName = plugin.postcssPlugin;\n        var pluginVer = plugin.postcssVersion;\n        var runtimeVer = this.result.processor.version;\n        var a = pluginVer.split('.');\n        var b = runtimeVer.split('.');\n        if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n          (0, _warnOnce2.default)('Your current PostCSS version ' + 'is ' + runtimeVer + ', but ' + pluginName + ' ' + 'uses ' + pluginVer + '. Perhaps this is ' + 'the source of the error below.');\n        }\n      }\n    } catch (err) {\n      if (console && console.error) console.error(err);\n    }\n  };\n  LazyResult.prototype.asyncTick = function asyncTick(resolve, reject) {\n    var _this = this;\n    if (this.plugin >= this.processor.plugins.length) {\n      this.processed = true;\n      return resolve();\n    }\n    try {\n      var plugin = this.processor.plugins[this.plugin];\n      var promise = this.run(plugin);\n      this.plugin += 1;\n      if (isPromise(promise)) {\n        promise.then(function () {\n          _this.asyncTick(resolve, reject);\n        }).catch(function (error) {\n          _this.handleError(error, plugin);\n          _this.processed = true;\n          reject(error);\n        });\n      } else {\n        this.asyncTick(resolve, reject);\n      }\n    } catch (error) {\n      this.processed = true;\n      reject(error);\n    }\n  };\n  LazyResult.prototype.async = function async() {\n    var _this2 = this;\n    if (this.processed) {\n      return new Promise(function (resolve, reject) {\n        if (_this2.error) {\n          reject(_this2.error);\n        } else {\n          resolve(_this2.stringify());\n        }\n      });\n    }\n    if (this.processing) {\n      return this.processing;\n    }\n    this.processing = new Promise(function (resolve, reject) {\n      if (_this2.error) return reject(_this2.error);\n      _this2.plugin = 0;\n      _this2.asyncTick(resolve, reject);\n    }).then(function () {\n      _this2.processed = true;\n      return _this2.stringify();\n    });\n    return this.processing;\n  };\n  LazyResult.prototype.sync = function sync() {\n    if (this.processed) return this.result;\n    this.processed = true;\n    if (this.processing) {\n      throw new Error('Use process(css).then(cb) to work with async plugins');\n    }\n    if (this.error) throw this.error;\n    for (var _iterator = this.result.processor.plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n      var plugin = _ref;\n      var promise = this.run(plugin);\n      if (isPromise(promise)) {\n        throw new Error('Use process(css).then(cb) to work with async plugins');\n      }\n    }\n    return this.result;\n  };\n  LazyResult.prototype.run = function run(plugin) {\n    this.result.lastPlugin = plugin;\n    try {\n      return plugin(this.result.root, this.result);\n    } catch (error) {\n      this.handleError(error, plugin);\n      throw error;\n    }\n  };\n  LazyResult.prototype.stringify = function stringify() {\n    if (this.stringified) return this.result;\n    this.stringified = true;\n    this.sync();\n    var opts = this.result.opts;\n    var str = _stringify3.default;\n    if (opts.syntax) str = opts.syntax.stringify;\n    if (opts.stringifier) str = opts.stringifier;\n    if (str.stringify) str = str.stringify;\n    var map = new _mapGenerator2.default(str, this.result.root, this.result.opts);\n    var data = map.generate();\n    this.result.css = data[0];\n    this.result.map = data[1];\n    return this.result;\n  };\n  _createClass(LazyResult, [{\n    key: 'processor',\n    get: function get() {\n      return this.result.processor;\n    }\n\n    /**\n     * Options from the {@link Processor#process} call.\n     * @type {processOptions}\n     */\n  }, {\n    key: 'opts',\n    get: function get() {\n      return this.result.opts;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins, converts `Root`\n     * to a CSS string and returns {@link Result#css}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#css\n     */\n  }, {\n    key: 'css',\n    get: function get() {\n      return this.stringify().css;\n    }\n\n    /**\n     * An alias for the `css` property. Use it with syntaxes\n     * that generate non-CSS output.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#content\n     */\n  }, {\n    key: 'content',\n    get: function get() {\n      return this.stringify().content;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#map}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {SourceMapGenerator}\n     * @see Result#map\n     */\n  }, {\n    key: 'map',\n    get: function get() {\n      return this.stringify().map;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#root}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Root}\n     * @see Result#root\n     */\n  }, {\n    key: 'root',\n    get: function get() {\n      return this.sync().root;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#messages}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Message[]}\n     * @see Result#messages\n     */\n  }, {\n    key: 'messages',\n    get: function get() {\n      return this.sync().messages;\n    }\n  }]);\n  return LazyResult;\n}();\nexports.default = LazyResult;\n\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n\nmodule.exports = exports['default'];","map":{"version":3,"names":["_mapGenerator","require","_stringify2","_warnOnce","_result","_parse","isPromise","obj","_typeof","then","LazyResult","processor","css","opts","_classCallCheck","stringified","processed","root","type","_result2","default","map","inline","prev","parser","_parse2","syntax","parse","error","result","warnings","sync","toString","onFulfilled","onRejected","async","catch","handleError","plugin","name","postcssPlugin","setMessage","postcssVersion","pluginName","pluginVer","runtimeVer","version","a","split","b","parseInt","_warnOnce2","err","console","asyncTick","resolve","reject","_this","plugins","length","promise","run","_this2","Promise","stringify","processing","Error","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref","next","done","value","lastPlugin","str","_stringify3","stringifier","_mapGenerator2","data","generate","content","messages"],"sources":["C:\\Users\\Francisco\\Documents\\GitHub\\examenApi\\EXAMEN-API-NOTICIAS\\node_modules\\postcss-scss\\node_modules\\postcss\\lib\\lazy-result.es6"],"sourcesContent":["import MapGenerator from './map-generator';\nimport stringify    from './stringify';\nimport warnOnce     from './warn-once';\nimport Result       from './result';\nimport parse        from './parse';\n\nfunction isPromise(obj) {\n    return typeof obj === 'object' && typeof obj.then === 'function';\n}\n\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([cssnext]).process(css);\n */\nclass LazyResult {\n\n    constructor(processor, css, opts) {\n        this.stringified = false;\n        this.processed   = false;\n\n        let root;\n        if ( typeof css === 'object' && css.type === 'root' ) {\n            root = css;\n        } else if ( css instanceof LazyResult || css instanceof Result ) {\n            root = css.root;\n            if ( css.map ) {\n                if ( typeof opts.map === 'undefined' ) opts.map = { };\n                if ( !opts.map.inline ) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            let parser = parse;\n            if ( opts.syntax )  parser = opts.syntax.parse;\n            if ( opts.parser )  parser = opts.parser;\n            if ( parser.parse ) parser = parser.parse;\n\n            try {\n                root = parser(css, opts);\n            } catch (error) {\n                this.error = error;\n            }\n        }\n\n        this.result = new Result(processor, root, opts);\n    }\n\n    /**\n     * Returns a {@link Processor} instance, which will be used\n     * for CSS transformations.\n     * @type {Processor}\n     */\n    get processor() {\n        return this.result.processor;\n    }\n\n    /**\n     * Options from the {@link Processor#process} call.\n     * @type {processOptions}\n     */\n    get opts() {\n        return this.result.opts;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins, converts `Root`\n     * to a CSS string and returns {@link Result#css}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#css\n     */\n    get css() {\n        return this.stringify().css;\n    }\n\n    /**\n     * An alias for the `css` property. Use it with syntaxes\n     * that generate non-CSS output.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#content\n     */\n    get content() {\n        return this.stringify().content;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#map}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {SourceMapGenerator}\n     * @see Result#map\n     */\n    get map() {\n        return this.stringify().map;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#root}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Root}\n     * @see Result#root\n     */\n    get root() {\n        return this.sync().root;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#messages}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Message[]}\n     * @see Result#messages\n     */\n    get messages() {\n        return this.sync().messages;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and calls {@link Result#warnings()}.\n     *\n     * @return {Warning[]} warnings from plugins\n     */\n    warnings() {\n        return this.sync().warnings();\n    }\n\n    /**\n     * Alias for the {@link LazyResult#css} property.\n     *\n     * @example\n     * lazy + '' === lazy.css;\n     *\n     * @return {string} output CSS\n     */\n    toString() {\n        return this.css;\n    }\n\n    /**\n     * Processes input CSS through synchronous and asynchronous plugins\n     * and calls `onFulfilled` with a Result instance. If a plugin throws\n     * an error, the `onRejected` callback will be executed.\n     *\n     * It implements standard Promise API.\n     *\n     * @param {onFulfilled} onFulfilled - callback will be executed\n     *                                    when all plugins will finish work\n     * @param {onRejected}  onRejected  - callback will be executed on any error\n     *\n     * @return {Promise} Promise API to make queue\n     *\n     * @example\n     * postcss([cssnext]).process(css).then(result => {\n     *   console.log(result.css);\n     * });\n     */\n    then(onFulfilled, onRejected) {\n        return this.async().then(onFulfilled, onRejected);\n    }\n\n    /**\n     * Processes input CSS through synchronous and asynchronous plugins\n     * and calls onRejected for each error thrown in any plugin.\n     *\n     * It implements standard Promise API.\n     *\n     * @param {onRejected} onRejected - callback will be executed on any error\n     *\n     * @return {Promise} Promise API to make queue\n     *\n     * @example\n     * postcss([cssnext]).process(css).then(result => {\n     *   console.log(result.css);\n     * }).catch(error => {\n     *   console.error(error);\n     * });\n     */\n    catch(onRejected) {\n        return this.async().catch(onRejected);\n    }\n\n    handleError(error, plugin) {\n        try {\n            this.error = error;\n            if ( error.name === 'CssSyntaxError' && !error.plugin ) {\n                error.plugin = plugin.postcssPlugin;\n                error.setMessage();\n            } else if ( plugin.postcssVersion ) {\n                let pluginName = plugin.postcssPlugin;\n                let pluginVer  = plugin.postcssVersion;\n                let runtimeVer = this.result.processor.version;\n                let a = pluginVer.split('.');\n                let b = runtimeVer.split('.');\n\n                if ( a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1]) ) {\n                    warnOnce('Your current PostCSS version ' +\n                             'is ' + runtimeVer + ', but ' + pluginName + ' ' +\n                             'uses ' + pluginVer + '. Perhaps this is ' +\n                             'the source of the error below.');\n                }\n            }\n        } catch (err) {\n            if ( console && console.error ) console.error(err);\n        }\n    }\n\n    asyncTick(resolve, reject) {\n        if ( this.plugin >= this.processor.plugins.length ) {\n            this.processed = true;\n            return resolve();\n        }\n\n        try {\n            let plugin  = this.processor.plugins[this.plugin];\n            let promise = this.run(plugin);\n            this.plugin += 1;\n\n            if ( isPromise(promise) ) {\n                promise.then( () => {\n                    this.asyncTick(resolve, reject);\n                }).catch( error => {\n                    this.handleError(error, plugin);\n                    this.processed = true;\n                    reject(error);\n                });\n            } else {\n                this.asyncTick(resolve, reject);\n            }\n\n        } catch (error) {\n            this.processed = true;\n            reject(error);\n        }\n    }\n\n    async() {\n        if ( this.processed ) {\n            return new Promise( (resolve, reject) => {\n                if ( this.error ) {\n                    reject(this.error);\n                } else {\n                    resolve(this.stringify());\n                }\n            });\n        }\n        if ( this.processing ) {\n            return this.processing;\n        }\n\n        this.processing = new Promise( (resolve, reject) => {\n            if ( this.error ) return reject(this.error);\n            this.plugin = 0;\n            this.asyncTick(resolve, reject);\n        }).then( () => {\n            this.processed = true;\n            return this.stringify();\n        });\n\n        return this.processing;\n    }\n\n    sync() {\n        if ( this.processed ) return this.result;\n        this.processed = true;\n\n        if ( this.processing ) {\n            throw new Error(\n                'Use process(css).then(cb) to work with async plugins');\n        }\n\n        if ( this.error ) throw this.error;\n\n        for ( let plugin of this.result.processor.plugins ) {\n            let promise = this.run(plugin);\n            if ( isPromise(promise) ) {\n                throw new Error(\n                    'Use process(css).then(cb) to work with async plugins');\n            }\n        }\n\n        return this.result;\n    }\n\n    run(plugin) {\n        this.result.lastPlugin = plugin;\n\n        try {\n            return plugin(this.result.root, this.result);\n        } catch (error) {\n            this.handleError(error, plugin);\n            throw error;\n        }\n    }\n\n    stringify() {\n        if ( this.stringified ) return this.result;\n        this.stringified = true;\n\n        this.sync();\n\n        let opts = this.result.opts;\n        let str  = stringify;\n        if ( opts.syntax )      str = opts.syntax.stringify;\n        if ( opts.stringifier ) str = opts.stringifier;\n        if ( str.stringify )    str = str.stringify;\n\n        let map  = new MapGenerator(str, this.result.root, this.result.opts);\n        let data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n\n        return this.result;\n    }\n\n}\n\nexport default LazyResult;\n\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}