{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar _cssSyntaxError = require('./css-syntax-error');\nvar _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);\nvar _stringifier = require('./stringifier');\nvar _stringifier2 = _interopRequireDefault(_stringifier);\nvar _stringify = require('./stringify');\nvar _stringify2 = _interopRequireDefault(_stringify);\nvar _warnOnce = require('./warn-once');\nvar _warnOnce2 = _interopRequireDefault(_warnOnce);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar cloneNode = function cloneNode(obj, parent) {\n  var cloned = new obj.constructor();\n  for (var i in obj) {\n    if (!obj.hasOwnProperty(i)) continue;\n    var value = obj[i];\n    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n    if (i === 'parent' && type === 'object') {\n      if (parent) cloned[i] = parent;\n    } else if (i === 'source') {\n      cloned[i] = value;\n    } else if (value instanceof Array) {\n      cloned[i] = value.map(function (j) {\n        return cloneNode(j, cloned);\n      });\n    } else {\n      if (type === 'object' && value !== null) value = cloneNode(value);\n      cloned[i] = value;\n    }\n  }\n  return cloned;\n};\n\n/**\n * All node classes inherit the following common methods.\n *\n * @abstract\n */\n\nvar Node = function () {\n  /**\n   * @param {object} [defaults] - value for node properties\n   */\n  function Node() {\n    var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Node);\n    this.raws = {};\n    if ((typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) !== 'object' && typeof defaults !== 'undefined') {\n      throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));\n    }\n    for (var name in defaults) {\n      this[name] = defaults[name];\n    }\n  }\n\n  /**\n   * Returns a CssSyntaxError instance containing the original position\n   * of the node in the source, showing line and column numbers and also\n   * a small excerpt to facilitate debugging.\n   *\n   * If present, an input source map will be used to get the original position\n   * of the source, even from a previous compilation step\n   * (e.g., from Sass compilation).\n   *\n   * This method produces very useful error messages.\n   *\n   * @param {string} message     - error description\n   * @param {object} [opts]      - options\n   * @param {string} opts.plugin - plugin name that created this error.\n   *                               PostCSS will set it automatically.\n   * @param {string} opts.word   - a word inside a node’s string that should\n   *                               be highlighted as the source of the error\n   * @param {number} opts.index  - an index inside a node’s string that should\n   *                               be highlighted as the source of the error\n   *\n   * @return {CssSyntaxError} error object to throw it\n   *\n   * @example\n   * if ( !variables[name] ) {\n   *   throw decl.error('Unknown variable ' + name, { word: name });\n   *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black\n   *   //   color: $black\n   *   // a\n   *   //          ^\n   *   //   background: white\n   * }\n   */\n\n  Node.prototype.error = function error(message) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (this.source) {\n      var pos = this.positionBy(opts);\n      return this.source.input.error(message, pos.line, pos.column, opts);\n    } else {\n      return new _cssSyntaxError2.default(message);\n    }\n  };\n\n  /**\n   * This method is provided as a convenience wrapper for {@link Result#warn}.\n   *\n   * @param {Result} result      - the {@link Result} instance\n   *                               that will receive the warning\n   * @param {string} text        - warning message\n   * @param {object} [opts]      - options\n   * @param {string} opts.plugin - plugin name that created this warning.\n   *                               PostCSS will set it automatically.\n   * @param {string} opts.word   - a word inside a node’s string that should\n   *                               be highlighted as the source of the warning\n   * @param {number} opts.index  - an index inside a node’s string that should\n   *                               be highlighted as the source of the warning\n   *\n   * @return {Warning} created warning object\n   *\n   * @example\n   * const plugin = postcss.plugin('postcss-deprecated', () => {\n   *   return (root, result) => {\n   *     root.walkDecls('bad', decl => {\n   *       decl.warn(result, 'Deprecated property bad');\n   *     });\n   *   };\n   * });\n   */\n\n  Node.prototype.warn = function warn(result, text, opts) {\n    var data = {\n      node: this\n    };\n    for (var i in opts) {\n      data[i] = opts[i];\n    }\n    return result.warn(text, data);\n  };\n\n  /**\n   * Removes the node from its parent and cleans the parent properties\n   * from the node and its children.\n   *\n   * @example\n   * if ( decl.prop.match(/^-webkit-/) ) {\n   *   decl.remove();\n   * }\n   *\n   * @return {Node} node to make calls chain\n   */\n\n  Node.prototype.remove = function remove() {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n    this.parent = undefined;\n    return this;\n  };\n\n  /**\n   * Returns a CSS string representing the node.\n   *\n   * @param {stringifier|syntax} [stringifier] - a syntax to use\n   *                                             in string generation\n   *\n   * @return {string} CSS string of this node\n   *\n   * @example\n   * postcss.rule({ selector: 'a' }).toString() //=> \"a {}\"\n   */\n\n  Node.prototype.toString = function toString() {\n    var stringifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _stringify2.default;\n    if (stringifier.stringify) stringifier = stringifier.stringify;\n    var result = '';\n    stringifier(this, function (i) {\n      result += i;\n    });\n    return result;\n  };\n\n  /**\n   * Returns a clone of the node.\n   *\n   * The resulting cloned node and its (cloned) children will have\n   * a clean parent and code style properties.\n   *\n   * @param {object} [overrides] - new properties to override in the clone.\n   *\n   * @example\n   * const cloned = decl.clone({ prop: '-moz-' + decl.prop });\n   * cloned.raws.before  //=> undefined\n   * cloned.parent       //=> undefined\n   * cloned.toString()   //=> -moz-transform: scale(0)\n   *\n   * @return {Node} clone of the node\n   */\n\n  Node.prototype.clone = function clone() {\n    var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var cloned = cloneNode(this);\n    for (var name in overrides) {\n      cloned[name] = overrides[name];\n    }\n    return cloned;\n  };\n\n  /**\n   * Shortcut to clone the node and insert the resulting cloned node\n   * before the current node.\n   *\n   * @param {object} [overrides] - new properties to override in the clone.\n   *\n   * @example\n   * decl.cloneBefore({ prop: '-moz-' + decl.prop });\n   *\n   * @return {Node} - new node\n   */\n\n  Node.prototype.cloneBefore = function cloneBefore() {\n    var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var cloned = this.clone(overrides);\n    this.parent.insertBefore(this, cloned);\n    return cloned;\n  };\n\n  /**\n   * Shortcut to clone the node and insert the resulting cloned node\n   * after the current node.\n   *\n   * @param {object} [overrides] - new properties to override in the clone.\n   *\n   * @return {Node} - new node\n   */\n\n  Node.prototype.cloneAfter = function cloneAfter() {\n    var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var cloned = this.clone(overrides);\n    this.parent.insertAfter(this, cloned);\n    return cloned;\n  };\n\n  /**\n   * Inserts node(s) before the current node and removes the current node.\n   *\n   * @param {...Node} nodes - node(s) to replace current one\n   *\n   * @example\n   * if ( atrule.name == 'mixin' ) {\n   *   atrule.replaceWith(mixinRules[atrule.params]);\n   * }\n   *\n   * @return {Node} current node to methods chain\n   */\n\n  Node.prototype.replaceWith = function replaceWith() {\n    if (this.parent) {\n      for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {\n        nodes[_key] = arguments[_key];\n      }\n      for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n        var node = _ref;\n        this.parent.insertBefore(this, node);\n      }\n      this.remove();\n    }\n    return this;\n  };\n  Node.prototype.moveTo = function moveTo(newParent) {\n    (0, _warnOnce2.default)('Node#moveTo was deprecated. Use Container#append.');\n    this.cleanRaws(this.root() === newParent.root());\n    this.remove();\n    newParent.append(this);\n    return this;\n  };\n  Node.prototype.moveBefore = function moveBefore(otherNode) {\n    (0, _warnOnce2.default)('Node#moveBefore was deprecated. Use Node#before.');\n    this.cleanRaws(this.root() === otherNode.root());\n    this.remove();\n    otherNode.parent.insertBefore(otherNode, this);\n    return this;\n  };\n  Node.prototype.moveAfter = function moveAfter(otherNode) {\n    (0, _warnOnce2.default)('Node#moveAfter was deprecated. Use Node#after.');\n    this.cleanRaws(this.root() === otherNode.root());\n    this.remove();\n    otherNode.parent.insertAfter(otherNode, this);\n    return this;\n  };\n\n  /**\n   * Returns the next child of the node’s parent.\n   * Returns `undefined` if the current node is the last child.\n   *\n   * @return {Node|undefined} next node\n   *\n   * @example\n   * if ( comment.text === 'delete next' ) {\n   *   const next = comment.next();\n   *   if ( next ) {\n   *     next.remove();\n   *   }\n   * }\n   */\n\n  Node.prototype.next = function next() {\n    if (!this.parent) return undefined;\n    var index = this.parent.index(this);\n    return this.parent.nodes[index + 1];\n  };\n\n  /**\n   * Returns the previous child of the node’s parent.\n   * Returns `undefined` if the current node is the first child.\n   *\n   * @return {Node|undefined} previous node\n   *\n   * @example\n   * const annotation = decl.prev();\n   * if ( annotation.type == 'comment' ) {\n   *  readAnnotation(annotation.text);\n   * }\n   */\n\n  Node.prototype.prev = function prev() {\n    if (!this.parent) return undefined;\n    var index = this.parent.index(this);\n    return this.parent.nodes[index - 1];\n  };\n\n  /**\n   * Insert new node before current node to current node’s parent.\n   *\n   * Just alias for `node.parent.insertBefore(node, add)`.\n   *\n   * @param {Node|object|string|Node[]} add - new node\n   *\n   * @return {Node} this node for methods chain.\n   *\n   * @example\n   * decl.before('content: \"\"');\n   */\n\n  Node.prototype.before = function before(add) {\n    this.parent.insertBefore(this, add);\n    return this;\n  };\n\n  /**\n   * Insert new node after current node to current node’s parent.\n   *\n   * Just alias for `node.parent.insertAfter(node, add)`.\n   *\n   * @param {Node|object|string|Node[]} add - new node\n   *\n   * @return {Node} this node for methods chain.\n   *\n   * @example\n   * decl.after('color: black');\n   */\n\n  Node.prototype.after = function after(add) {\n    this.parent.insertAfter(this, add);\n    return this;\n  };\n  Node.prototype.toJSON = function toJSON() {\n    var fixed = {};\n    for (var name in this) {\n      if (!this.hasOwnProperty(name)) continue;\n      if (name === 'parent') continue;\n      var value = this[name];\n      if (value instanceof Array) {\n        fixed[name] = value.map(function (i) {\n          if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && i.toJSON) {\n            return i.toJSON();\n          } else {\n            return i;\n          }\n        });\n      } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.toJSON) {\n        fixed[name] = value.toJSON();\n      } else {\n        fixed[name] = value;\n      }\n    }\n    return fixed;\n  };\n\n  /**\n   * Returns a {@link Node#raws} value. If the node is missing\n   * the code style property (because the node was manually built or cloned),\n   * PostCSS will try to autodetect the code style property by looking\n   * at other nodes in the tree.\n   *\n   * @param {string} prop          - name of code style property\n   * @param {string} [defaultType] - name of default value, it can be missed\n   *                                 if the value is the same as prop\n   *\n   * @example\n   * const root = postcss.parse('a { background: white }');\n   * root.nodes[0].append({ prop: 'color', value: 'black' });\n   * root.nodes[0].nodes[1].raws.before   //=> undefined\n   * root.nodes[0].nodes[1].raw('before') //=> ' '\n   *\n   * @return {string} code style value\n   */\n\n  Node.prototype.raw = function raw(prop, defaultType) {\n    var str = new _stringifier2.default();\n    return str.raw(this, prop, defaultType);\n  };\n\n  /**\n   * Finds the Root instance of the node’s tree.\n   *\n   * @example\n   * root.nodes[0].nodes[0].root() === root\n   *\n   * @return {Root} root parent\n   */\n\n  Node.prototype.root = function root() {\n    var result = this;\n    while (result.parent) {\n      result = result.parent;\n    }\n    return result;\n  };\n  Node.prototype.cleanRaws = function cleanRaws(keepBetween) {\n    delete this.raws.before;\n    delete this.raws.after;\n    if (!keepBetween) delete this.raws.between;\n  };\n  Node.prototype.positionInside = function positionInside(index) {\n    var string = this.toString();\n    var column = this.source.start.column;\n    var line = this.source.start.line;\n    for (var i = 0; i < index; i++) {\n      if (string[i] === '\\n') {\n        column = 1;\n        line += 1;\n      } else {\n        column += 1;\n      }\n    }\n    return {\n      line: line,\n      column: column\n    };\n  };\n  Node.prototype.positionBy = function positionBy(opts) {\n    var pos = this.source.start;\n    if (opts.index) {\n      pos = this.positionInside(opts.index);\n    } else if (opts.word) {\n      var index = this.toString().indexOf(opts.word);\n      if (index !== -1) pos = this.positionInside(index);\n    }\n    return pos;\n  };\n\n  /**\n   * @memberof Node#\n   * @member {string} type - String representing the node’s type.\n   *                         Possible values are `root`, `atrule`, `rule`,\n   *                         `decl`, or `comment`.\n   *\n   * @example\n   * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'\n   */\n\n  /**\n   * @memberof Node#\n   * @member {Container} parent - the node’s parent node.\n   *\n   * @example\n   * root.nodes[0].parent == root;\n   */\n\n  /**\n   * @memberof Node#\n   * @member {source} source - the input source of the node\n   *\n   * The property is used in source map generation.\n   *\n   * If you create a node manually (e.g., with `postcss.decl()`),\n   * that node will not have a `source` property and will be absent\n   * from the source map. For this reason, the plugin developer should\n   * consider cloning nodes to create new ones (in which case the new node’s\n   * source will reference the original, cloned node) or setting\n   * the `source` property manually.\n   *\n   * ```js\n   * // Bad\n   * const prefixed = postcss.decl({\n   *   prop: '-moz-' + decl.prop,\n   *   value: decl.value\n   * });\n   *\n   * // Good\n   * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });\n   * ```\n   *\n   * ```js\n   * if ( atrule.name == 'add-link' ) {\n   *   const rule = postcss.rule({ selector: 'a', source: atrule.source });\n   *   atrule.parent.insertBefore(atrule, rule);\n   * }\n   * ```\n   *\n   * @example\n   * decl.source.input.from //=> '/home/ai/a.sass'\n   * decl.source.start      //=> { line: 10, column: 2 }\n   * decl.source.end        //=> { line: 10, column: 12 }\n   */\n\n  /**\n   * @memberof Node#\n   * @member {object} raws - Information to generate byte-to-byte equal\n   *                         node string as it was in the origin input.\n   *\n   * Every parser saves its own properties,\n   * but the default CSS parser uses:\n   *\n   * * `before`: the space symbols before the node. It also stores `*`\n   *   and `_` symbols before the declaration (IE hack).\n   * * `after`: the space symbols after the last child of the node\n   *   to the end of the node.\n   * * `between`: the symbols between the property and value\n   *   for declarations, selector and `{` for rules, or last parameter\n   *   and `{` for at-rules.\n   * * `semicolon`: contains true if the last child has\n   *   an (optional) semicolon.\n   * * `afterName`: the space between the at-rule name and its parameters.\n   * * `left`: the space symbols between `/*` and the comment’s text.\n   * * `right`: the space symbols between the comment’s text\n   *   and <code>*&#47;</code>.\n   * * `important`: the content of the important statement,\n   *   if it is not just `!important`.\n   *\n   * PostCSS cleans selectors, declaration values and at-rule parameters\n   * from comments and extra spaces, but it stores origin content in raws\n   * properties. As such, if you don’t change a declaration’s value,\n   * PostCSS will use the raw value with comments.\n   *\n   * @example\n   * const root = postcss.parse('a {\\n  color:black\\n}')\n   * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n   */\n\n  return Node;\n}();\nexports.default = Node;\n\n/**\n * @typedef {object} position\n * @property {number} line   - source line in file\n * @property {number} column - source column in file\n */\n\n/**\n * @typedef {object} source\n * @property {Input} input    - {@link Input} with input file\n * @property {position} start - The starting position of the node’s source\n * @property {position} end   - The ending position of the node’s source\n */\n\nmodule.exports = exports['default'];","map":{"version":3,"names":["_cssSyntaxError","require","_stringifier","_stringify","_warnOnce","cloneNode","obj","parent","cloned","constructor","i","hasOwnProperty","value","type","_typeof","Array","map","j","Node","defaults","arguments","length","undefined","_classCallCheck","raws","Error","JSON","stringify","name","error","message","opts","source","pos","positionBy","input","line","column","_cssSyntaxError2","default","warn","result","text","data","node","remove","removeChild","toString","stringifier","_stringify2","clone","overrides","cloneBefore","insertBefore","cloneAfter","insertAfter","replaceWith","_len","nodes","_key","_iterator","_isArray","isArray","_i","Symbol","iterator","_ref","next","done","moveTo","newParent","_warnOnce2","cleanRaws","root","append","moveBefore","otherNode","moveAfter","index","prev","before","add","after","toJSON","fixed","raw","prop","defaultType","str","_stringifier2","keepBetween","between","positionInside","string","start","word","indexOf"],"sources":["C:\\Users\\Francisco\\Documents\\GitHub\\examenApi\\EXAMEN-API-NOTICIAS\\node_modules\\postcss-functions\\node_modules\\postcss\\lib\\node.es6"],"sourcesContent":["import CssSyntaxError from './css-syntax-error';\nimport Stringifier    from './stringifier';\nimport stringify      from './stringify';\nimport warnOnce       from './warn-once';\n\nlet cloneNode = function (obj, parent) {\n    let cloned = new obj.constructor();\n\n    for ( let i in obj ) {\n        if ( !obj.hasOwnProperty(i) ) continue;\n        let value = obj[i];\n        let type  = typeof value;\n\n        if ( i === 'parent' && type === 'object' ) {\n            if (parent) cloned[i] = parent;\n        } else if ( i === 'source' ) {\n            cloned[i] = value;\n        } else if ( value instanceof Array ) {\n            cloned[i] = value.map( j => cloneNode(j, cloned) );\n        } else {\n            if ( type === 'object' && value !== null ) value = cloneNode(value);\n            cloned[i] = value;\n        }\n    }\n\n    return cloned;\n};\n\n/**\n * All node classes inherit the following common methods.\n *\n * @abstract\n */\nclass Node {\n\n    /**\n     * @param {object} [defaults] - value for node properties\n     */\n    constructor(defaults = { }) {\n        this.raws = { };\n        if ( typeof defaults !== 'object' && typeof defaults !== 'undefined' ) {\n            throw new Error(\n                'PostCSS nodes constructor accepts object, not ' +\n                JSON.stringify(defaults));\n        }\n        for ( let name in defaults ) {\n            this[name] = defaults[name];\n        }\n    }\n\n    /**\n     * Returns a CssSyntaxError instance containing the original position\n     * of the node in the source, showing line and column numbers and also\n     * a small excerpt to facilitate debugging.\n     *\n     * If present, an input source map will be used to get the original position\n     * of the source, even from a previous compilation step\n     * (e.g., from Sass compilation).\n     *\n     * This method produces very useful error messages.\n     *\n     * @param {string} message     - error description\n     * @param {object} [opts]      - options\n     * @param {string} opts.plugin - plugin name that created this error.\n     *                               PostCSS will set it automatically.\n     * @param {string} opts.word   - a word inside a node’s string that should\n     *                               be highlighted as the source of the error\n     * @param {number} opts.index  - an index inside a node’s string that should\n     *                               be highlighted as the source of the error\n     *\n     * @return {CssSyntaxError} error object to throw it\n     *\n     * @example\n     * if ( !variables[name] ) {\n     *   throw decl.error('Unknown variable ' + name, { word: name });\n     *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black\n     *   //   color: $black\n     *   // a\n     *   //          ^\n     *   //   background: white\n     * }\n     */\n    error(message, opts = { }) {\n        if ( this.source ) {\n            let pos = this.positionBy(opts);\n            return this.source.input.error(message, pos.line, pos.column, opts);\n        } else {\n            return new CssSyntaxError(message);\n        }\n    }\n\n    /**\n     * This method is provided as a convenience wrapper for {@link Result#warn}.\n     *\n     * @param {Result} result      - the {@link Result} instance\n     *                               that will receive the warning\n     * @param {string} text        - warning message\n     * @param {object} [opts]      - options\n     * @param {string} opts.plugin - plugin name that created this warning.\n     *                               PostCSS will set it automatically.\n     * @param {string} opts.word   - a word inside a node’s string that should\n     *                               be highlighted as the source of the warning\n     * @param {number} opts.index  - an index inside a node’s string that should\n     *                               be highlighted as the source of the warning\n     *\n     * @return {Warning} created warning object\n     *\n     * @example\n     * const plugin = postcss.plugin('postcss-deprecated', () => {\n     *   return (root, result) => {\n     *     root.walkDecls('bad', decl => {\n     *       decl.warn(result, 'Deprecated property bad');\n     *     });\n     *   };\n     * });\n     */\n    warn(result, text, opts) {\n        let data = { node: this };\n        for ( let i in opts ) data[i] = opts[i];\n        return result.warn(text, data);\n    }\n\n    /**\n     * Removes the node from its parent and cleans the parent properties\n     * from the node and its children.\n     *\n     * @example\n     * if ( decl.prop.match(/^-webkit-/) ) {\n     *   decl.remove();\n     * }\n     *\n     * @return {Node} node to make calls chain\n     */\n    remove() {\n        if ( this.parent ) {\n            this.parent.removeChild(this);\n        }\n        this.parent = undefined;\n        return this;\n    }\n\n    /**\n     * Returns a CSS string representing the node.\n     *\n     * @param {stringifier|syntax} [stringifier] - a syntax to use\n     *                                             in string generation\n     *\n     * @return {string} CSS string of this node\n     *\n     * @example\n     * postcss.rule({ selector: 'a' }).toString() //=> \"a {}\"\n     */\n    toString(stringifier = stringify) {\n        if ( stringifier.stringify ) stringifier = stringifier.stringify;\n        let result  = '';\n        stringifier(this, i => {\n            result += i;\n        });\n        return result;\n    }\n\n    /**\n     * Returns a clone of the node.\n     *\n     * The resulting cloned node and its (cloned) children will have\n     * a clean parent and code style properties.\n     *\n     * @param {object} [overrides] - new properties to override in the clone.\n     *\n     * @example\n     * const cloned = decl.clone({ prop: '-moz-' + decl.prop });\n     * cloned.raws.before  //=> undefined\n     * cloned.parent       //=> undefined\n     * cloned.toString()   //=> -moz-transform: scale(0)\n     *\n     * @return {Node} clone of the node\n     */\n    clone(overrides = { }) {\n        let cloned = cloneNode(this);\n        for ( let name in overrides ) {\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    }\n\n    /**\n     * Shortcut to clone the node and insert the resulting cloned node\n     * before the current node.\n     *\n     * @param {object} [overrides] - new properties to override in the clone.\n     *\n     * @example\n     * decl.cloneBefore({ prop: '-moz-' + decl.prop });\n     *\n     * @return {Node} - new node\n     */\n    cloneBefore(overrides = { }) {\n        let cloned = this.clone(overrides);\n        this.parent.insertBefore(this, cloned);\n        return cloned;\n    }\n\n    /**\n     * Shortcut to clone the node and insert the resulting cloned node\n     * after the current node.\n     *\n     * @param {object} [overrides] - new properties to override in the clone.\n     *\n     * @return {Node} - new node\n     */\n    cloneAfter(overrides = { }) {\n        let cloned = this.clone(overrides);\n        this.parent.insertAfter(this, cloned);\n        return cloned;\n    }\n\n    /**\n     * Inserts node(s) before the current node and removes the current node.\n     *\n     * @param {...Node} nodes - node(s) to replace current one\n     *\n     * @example\n     * if ( atrule.name == 'mixin' ) {\n     *   atrule.replaceWith(mixinRules[atrule.params]);\n     * }\n     *\n     * @return {Node} current node to methods chain\n     */\n    replaceWith(...nodes) {\n        if (this.parent) {\n            for (let node of nodes) {\n                this.parent.insertBefore(this, node);\n            }\n\n            this.remove();\n        }\n\n        return this;\n    }\n\n    moveTo(newParent) {\n        warnOnce('Node#moveTo was deprecated. Use Container#append.');\n        this.cleanRaws(this.root() === newParent.root());\n        this.remove();\n        newParent.append(this);\n        return this;\n    }\n\n    moveBefore(otherNode) {\n        warnOnce('Node#moveBefore was deprecated. Use Node#before.');\n        this.cleanRaws(this.root() === otherNode.root());\n        this.remove();\n        otherNode.parent.insertBefore(otherNode, this);\n        return this;\n    }\n\n    moveAfter(otherNode) {\n        warnOnce('Node#moveAfter was deprecated. Use Node#after.');\n        this.cleanRaws(this.root() === otherNode.root());\n        this.remove();\n        otherNode.parent.insertAfter(otherNode, this);\n        return this;\n    }\n\n    /**\n     * Returns the next child of the node’s parent.\n     * Returns `undefined` if the current node is the last child.\n     *\n     * @return {Node|undefined} next node\n     *\n     * @example\n     * if ( comment.text === 'delete next' ) {\n     *   const next = comment.next();\n     *   if ( next ) {\n     *     next.remove();\n     *   }\n     * }\n     */\n    next() {\n        if ( !this.parent ) return undefined;\n        let index = this.parent.index(this);\n        return this.parent.nodes[index + 1];\n    }\n\n    /**\n     * Returns the previous child of the node’s parent.\n     * Returns `undefined` if the current node is the first child.\n     *\n     * @return {Node|undefined} previous node\n     *\n     * @example\n     * const annotation = decl.prev();\n     * if ( annotation.type == 'comment' ) {\n     *  readAnnotation(annotation.text);\n     * }\n     */\n    prev() {\n        if ( !this.parent ) return undefined;\n        let index = this.parent.index(this);\n        return this.parent.nodes[index - 1];\n    }\n\n    /**\n     * Insert new node before current node to current node’s parent.\n     *\n     * Just alias for `node.parent.insertBefore(node, add)`.\n     *\n     * @param {Node|object|string|Node[]} add - new node\n     *\n     * @return {Node} this node for methods chain.\n     *\n     * @example\n     * decl.before('content: \"\"');\n     */\n    before(add) {\n        this.parent.insertBefore(this, add);\n        return this;\n    }\n\n    /**\n     * Insert new node after current node to current node’s parent.\n     *\n     * Just alias for `node.parent.insertAfter(node, add)`.\n     *\n     * @param {Node|object|string|Node[]} add - new node\n     *\n     * @return {Node} this node for methods chain.\n     *\n     * @example\n     * decl.after('color: black');\n     */\n    after(add) {\n        this.parent.insertAfter(this, add);\n        return this;\n    }\n\n    toJSON() {\n        let fixed = { };\n\n        for ( let name in this ) {\n            if ( !this.hasOwnProperty(name) ) continue;\n            if ( name === 'parent' ) continue;\n            let value = this[name];\n\n            if ( value instanceof Array ) {\n                fixed[name] = value.map( i => {\n                    if ( typeof i === 'object' && i.toJSON ) {\n                        return i.toJSON();\n                    } else {\n                        return i;\n                    }\n                });\n            } else if ( typeof value === 'object' && value.toJSON ) {\n                fixed[name] = value.toJSON();\n            } else {\n                fixed[name] = value;\n            }\n        }\n\n        return fixed;\n    }\n\n    /**\n     * Returns a {@link Node#raws} value. If the node is missing\n     * the code style property (because the node was manually built or cloned),\n     * PostCSS will try to autodetect the code style property by looking\n     * at other nodes in the tree.\n     *\n     * @param {string} prop          - name of code style property\n     * @param {string} [defaultType] - name of default value, it can be missed\n     *                                 if the value is the same as prop\n     *\n     * @example\n     * const root = postcss.parse('a { background: white }');\n     * root.nodes[0].append({ prop: 'color', value: 'black' });\n     * root.nodes[0].nodes[1].raws.before   //=> undefined\n     * root.nodes[0].nodes[1].raw('before') //=> ' '\n     *\n     * @return {string} code style value\n     */\n    raw(prop, defaultType) {\n        let str = new Stringifier();\n        return str.raw(this, prop, defaultType);\n    }\n\n    /**\n     * Finds the Root instance of the node’s tree.\n     *\n     * @example\n     * root.nodes[0].nodes[0].root() === root\n     *\n     * @return {Root} root parent\n     */\n    root() {\n        let result = this;\n        while ( result.parent ) result = result.parent;\n        return result;\n    }\n\n    cleanRaws(keepBetween) {\n        delete this.raws.before;\n        delete this.raws.after;\n        if ( !keepBetween ) delete this.raws.between;\n    }\n\n    positionInside(index) {\n        let string = this.toString();\n        let column = this.source.start.column;\n        let line   = this.source.start.line;\n\n        for ( let i = 0; i < index; i++ ) {\n            if ( string[i] === '\\n' ) {\n                column = 1;\n                line  += 1;\n            } else {\n                column += 1;\n            }\n        }\n\n        return { line, column };\n    }\n\n    positionBy(opts) {\n        let pos = this.source.start;\n        if ( opts.index ) {\n            pos = this.positionInside(opts.index);\n        } else if ( opts.word ) {\n            let index = this.toString().indexOf(opts.word);\n            if ( index !== -1 ) pos = this.positionInside(index);\n        }\n        return pos;\n    }\n\n    /**\n     * @memberof Node#\n     * @member {string} type - String representing the node’s type.\n     *                         Possible values are `root`, `atrule`, `rule`,\n     *                         `decl`, or `comment`.\n     *\n     * @example\n     * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'\n     */\n\n    /**\n     * @memberof Node#\n     * @member {Container} parent - the node’s parent node.\n     *\n     * @example\n     * root.nodes[0].parent == root;\n     */\n\n    /**\n     * @memberof Node#\n     * @member {source} source - the input source of the node\n     *\n     * The property is used in source map generation.\n     *\n     * If you create a node manually (e.g., with `postcss.decl()`),\n     * that node will not have a `source` property and will be absent\n     * from the source map. For this reason, the plugin developer should\n     * consider cloning nodes to create new ones (in which case the new node’s\n     * source will reference the original, cloned node) or setting\n     * the `source` property manually.\n     *\n     * ```js\n     * // Bad\n     * const prefixed = postcss.decl({\n     *   prop: '-moz-' + decl.prop,\n     *   value: decl.value\n     * });\n     *\n     * // Good\n     * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });\n     * ```\n     *\n     * ```js\n     * if ( atrule.name == 'add-link' ) {\n     *   const rule = postcss.rule({ selector: 'a', source: atrule.source });\n     *   atrule.parent.insertBefore(atrule, rule);\n     * }\n     * ```\n     *\n     * @example\n     * decl.source.input.from //=> '/home/ai/a.sass'\n     * decl.source.start      //=> { line: 10, column: 2 }\n     * decl.source.end        //=> { line: 10, column: 12 }\n     */\n\n    /**\n     * @memberof Node#\n     * @member {object} raws - Information to generate byte-to-byte equal\n     *                         node string as it was in the origin input.\n     *\n     * Every parser saves its own properties,\n     * but the default CSS parser uses:\n     *\n     * * `before`: the space symbols before the node. It also stores `*`\n     *   and `_` symbols before the declaration (IE hack).\n     * * `after`: the space symbols after the last child of the node\n     *   to the end of the node.\n     * * `between`: the symbols between the property and value\n     *   for declarations, selector and `{` for rules, or last parameter\n     *   and `{` for at-rules.\n     * * `semicolon`: contains true if the last child has\n     *   an (optional) semicolon.\n     * * `afterName`: the space between the at-rule name and its parameters.\n     * * `left`: the space symbols between `/*` and the comment’s text.\n     * * `right`: the space symbols between the comment’s text\n     *   and <code>*&#47;</code>.\n     * * `important`: the content of the important statement,\n     *   if it is not just `!important`.\n     *\n     * PostCSS cleans selectors, declaration values and at-rule parameters\n     * from comments and extra spaces, but it stores origin content in raws\n     * properties. As such, if you don’t change a declaration’s value,\n     * PostCSS will use the raw value with comments.\n     *\n     * @example\n     * const root = postcss.parse('a {\\n  color:black\\n}')\n     * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n     */\n\n}\n\nexport default Node;\n\n/**\n * @typedef {object} position\n * @property {number} line   - source line in file\n * @property {number} column - source column in file\n */\n\n/**\n * @typedef {object} source\n * @property {Input} input    - {@link Input} with input file\n * @property {position} start - The starting position of the node’s source\n * @property {position} end   - The ending position of the node’s source\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}